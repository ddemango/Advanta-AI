1) API routes (Next.js App Router)

Create these files:

app/api/matchmaker/retrieve/route.ts
import { NextRequest, NextResponse } from "next/server";

const TMDB_BASE = "https://api.themoviedb.org/3";
const IMG_BASE = "https://image.tmdb.org/t/p/w500";
const SERVICE_TO_TMDB_PROVIDER: Record<string, number> = {
  netflix: 8, prime: 9, disney: 337, hulu: 15, max: 384,
  peacock: 387, paramount: 531, apple: 350,
};

function poster(path?: string|null) { return path ? `${IMG_BASE}${path}` : undefined; }
function apiKey() {
  const k = process.env.TMDB_API_KEY;
  if (!k) throw new Error("TMDB_API_KEY not set");
  return k;
}

export async function POST(req: NextRequest) {
  try {
    const { services, timeWindow = 120, languages = ["en-US"], mediaTypes = ["movie","tv"], count = 100 } = await req.json();

    if (!Array.isArray(services) || services.length === 0) {
      return NextResponse.json({ error: "services required" }, { status: 400 });
    }

    const region = process.env.WATCH_REGION || "US";
    const providers = services.map((s: string) => SERVICE_TO_TMDB_PROVIDER[s]).filter(Boolean).join("|");

    async function discover(media: "movie"|"tv") {
      const params = new URLSearchParams({
        api_key: apiKey(),
        language: languages[0] || "en-US",
        sort_by: "popularity.desc",
        watch_region: region,
        ...(providers ? { with_watch_providers: providers } : {}),
        ...(media === "movie" && timeWindow ? { "with_runtime.lte": String(timeWindow + 20) } : {}),
      });
      const r = await fetch(`${TMDB_BASE}/discover/${media}?${params}`, { next: { revalidate: 3600 }});
      if (!r.ok) throw new Error(`discover ${media} ${r.status}`);
      const j = await r.json();
      return (j.results || []).slice(0, Math.ceil(count/(mediaTypes as string[]).length)).map((it: any) => ({
        id: it.id,
        media_type: media,
        title: media === "movie" ? it.title : it.name,
        year: (it.release_date || it.first_air_date)?.slice(0,4) ? Number((it.release_date || it.first_air_date).slice(0,4)) : undefined,
        overview: it.overview || "",
        poster_url: poster(it.poster_path),
        tmdb_url: `https://www.themoviedb.org/${media}/${it.id}`,
        popularity: it.popularity,
        genres: it.genre_ids || [], // number[]
      }));
    }

    const lists = await Promise.all((mediaTypes as ("movie"|"tv")[]).map(discover));
    const candidates = lists.flat();

    // Enrich top N with runtime + providers
    const detail = async (item: any) => {
      const det = await fetch(`${TMDB_BASE}/${item.media_type}/${item.id}?api_key=${apiKey()}`, { next: { revalidate: 86400 }});
      const dj = det.ok ? await det.json() : {};
      const runtime = item.media_type === "movie" ? dj.runtime : (dj.episode_run_time?.[0] || undefined);

      const prov = await fetch(`${TMDB_BASE}/${item.media_type}/${item.id}/watch/providers?api_key=${apiKey()}`, { next: { revalidate: 3600 }});
      const pj = prov.ok ? await pjToJsonSafe(prov) : {};
      const rinfo = (pj as any)?.results?.[region];
      const norm = (arr?: any[]) => arr?.map(p => p.provider_name) || [];

      return {
        ...item,
        runtime,
        providers: rinfo ? {
          flatrate: norm(rinfo.flatrate),
          ads: norm(rinfo.ads),
          rent: norm(rinfo.rent),
          buy: norm(rinfo.buy),
        } : {},
      };
    };

    const enriched = await Promise.all(candidates.slice(0, 40).map(detail));
    return NextResponse.json({ items: enriched, total: enriched.length });
  } catch (e: any) {
    return NextResponse.json({ error: e.message || "retrieve_failed" }, { status: 500 });
  }
}

async function pjToJsonSafe(res: Response) {
  try { return await res.json(); } catch { return {}; }
}

app/api/matchmaker/rerank/route.ts
import { NextRequest, NextResponse } from "next/server";

const MOOD_GENRE_WEIGHTS: Record<string, Record<number, number>> = {
  cozy:{35:1,10749:0.6,16:0.3}, light:{35:0.8,12:0.6}, intense:{53:1,28:0.8,80:0.6},
  smart:{18:0.6,9648:0.8,99:0.6,878:0.5}, gritty:{80:0.9,18:0.5,53:0.7},
  comfort:{35:0.7,10751:0.6}, high_energy:{28:0.8,12:0.7}, low_energy:{18:0.6,10749:0.4},
  multitask:{35:0.5,10751:0.4}, focus:{9648:0.7,18:0.6,99:0.6},
};
function gauss(x:number, mu:number, sigma:number){ const d=x-mu; return Math.exp(-(d*d)/(2*sigma*sigma)); }
function score(item:any, moods:string[], timeWindow:number){
  const timeFit = item.runtime ? gauss(item.runtime, timeWindow, Math.max(15, timeWindow*0.25)) : 0.8;
  const mood = moods.reduce((acc,m) => {
    const w = MOOD_GENRE_WEIGHTS[m] || {};
    return acc + (item.genres?.reduce((s:number,g:number)=> s + (w[g]||0), 0) || 0);
  }, 0);
  const recency = item.year ? Math.max(0, Math.min(1, (item.year - 1990) / 35)) : 0.3;
  const pop = item.popularity ? Math.min(1, item.popularity / 100) : 0.3;
  return 0.35*timeFit + 0.25*(mood/2) + 0.20*recency + 0.20*pop;
}

export async function POST(req: NextRequest) {
  try {
    const { candidates = [], moods = [], timeWindow = 120 } = await req.json();
    if (!Array.isArray(candidates)) return NextResponse.json({ error: "candidates required" }, { status: 400 });
    if (!moods.length) return NextResponse.json({ error: "moods required" }, { status: 400 });

    const items = candidates
      .map((c:any) => ({ ...c, match_score: Math.round(score(c, moods, timeWindow)*100) }))
      .sort((a:any,b:any) => (b.match_score||0) - (a.match_score||0))
      .slice(0, 30);

    return NextResponse.json({ items, total: items.length });
  } catch (e:any) {
    return NextResponse.json({ error: e.message || "rerank_failed" }, { status: 500 });
  }
}

app/api/matchmaker/explain/route.ts
import { NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
  const { item, moods = [], timeWindow = 120 } = await req.json();
  if (!item) return NextResponse.json({ error: "item required" }, { status: 400 });

  if (!process.env.OPENAI_API_KEY) {
    const primary = moods[0] || "entertaining";
    return NextResponse.json({ reason: `Fits your ${primary} mood and ~${item.runtime || "flex"} min window without spoilers.` });
  }

  try {
    const model = process.env.OPENAI_MODEL || "gpt-4o-mini";
    const sys = "Return ONE spoiler-safe reason under 20 words. Mention mood/length; no twists.";
    const user = `Title: ${item.title}\nMoods: ${moods.join(", ")}\nTime: ${timeWindow} min\nOverview: ${item.overview || ""}`;

    const r = await fetch("https://api.openai.com/v1/chat/completions", {
      method:"POST",
      headers:{ "Content-Type":"application/json", "Authorization":`Bearer ${process.env.OPENAI_API_KEY}` },
      body: JSON.stringify({ model, messages:[{role:"system",content:sys},{role:"user",content:user}], temperature:0.5, max_tokens:40 })
    });
    const j = await r.json();
    return NextResponse.json({ reason: j.choices?.[0]?.message?.content?.trim() || "Great mood and length fit." });
  } catch {
    return NextResponse.json({ reason: "Great mood and length fit." });
  }
}


(Optional) app/api/matchmaker/track/route.ts – if you call it:

import { NextResponse } from "next/server";
export async function POST(req: Request) {
  try { console.log("[track]", await req.json()); } catch {}
  return NextResponse.json({ ok: true });
}

2) Client patches (exactly 5 unique + better error + providers)

Make these small changes in your MovieTVMatchmaker component.

a) Fix ContentItem type (genres as numbers)
// change
// genres?: string[];
// to
genres?: number[];

b) Add “seen” helpers (top of file, above component)
const SEEN_KEY = 'matchmaker_seen_v1';
const SEEN_TTL_MS = 1000*60*60*24*14;
type Seen = { id:number; ts:number };
const loadSeen = ():Seen[] => {
  try { return (JSON.parse(localStorage.getItem(SEEN_KEY) || '[]') as Seen[]).filter(e => Date.now()-e.ts < SEEN_TTL_MS); } catch { return []; }
};
const saveSeen = (arr:Seen[]) => localStorage.setItem(SEEN_KEY, JSON.stringify(arr.slice(-80)));
const markSeen = (ids:number[]) => saveSeen([ ...loadSeen(), ...ids.map(id=>({ id, ts: Date.now() })) ]);
const filterUnseen = (items:ContentItem[], take:number) => {
  const seen = new Set(loadSeen().map(s=>s.id));
  const unseen = items.filter(i => !seen.has(i.id));
  return (unseen.length >= take ? unseen : [...unseen, ...items.filter(i=>seen.has(i.id))]).slice(0, take);
};

c) Harden fetch + enforce 5 unique
const handleGenerateRecommendations = async () => {
  setIsLoading(true);
  setError(null);

  try {
    const retrieveResponse = await fetch('/api/matchmaker/retrieve', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        services: preferences.services,
        timeWindow: preferences.timeWindow,
        languages: [preferences.language],
        mediaTypes: preferences.contentTypes,
        count: 160
      })
    });
    const retrieveJson = await safeJson(retrieveResponse);
    if (!retrieveResponse.ok) throw new Error(retrieveJson?.error || `retrieve ${retrieveResponse.status}`);
    const candidates: ContentItem[] = retrieveJson.items || [];

    const rerankResponse = await fetch('/api/matchmaker/rerank', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ candidates, moods: preferences.moods, timeWindow: preferences.timeWindow })
    });
    const rerankJson = await safeJson(rerankResponse);
    if (!rerankResponse.ok) throw new Error(rerankJson?.error || `rerank ${rerankResponse.status}`);

    const ranked: ContentItem[] = rerankJson.items || [];
    const five = filterUnseen(ranked, 5);
    markSeen(five.map(i => i.id));

    const withReasons = await Promise.all(five.map(async (item) => {
      const ex = await fetch('/api/matchmaker/explain', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ item, moods: preferences.moods, timeWindow: preferences.timeWindow })
      });
      const exJson = await safeJson(ex);
      return ex.ok && exJson?.reason ? { ...item, explanation: exJson.reason } : item;
    }));

    setRecommendations(withReasons);
    setShowResults(true);
  } catch (err:any) {
    setError(err.message || 'Unexpected error');
  } finally {
    setIsLoading(false);
  }
};

async function safeJson(r: Response) {
  try { return await r.json(); } catch { return null; }
}

d) Show “where to watch” + 1-click open

Add helpers (near the top):

const NAME_MAP: Record<string, string> = {
  'netflix':'netflix','hulu':'hulu','amazon prime video':'prime','prime video':'prime',
  'disney+':'disney','disney plus':'disney','max':'max','hbo max':'max','peacock':'peacock',
  'paramount+':'paramount','paramount plus':'paramount','apple tv+':'apple','apple tv plus':'apple',
};
const WATCH_URL: Record<string,(t:string)=>string> = {
  netflix:t=>`https://www.netflix.com/search?q=${encodeURIComponent(t)}`,
  hulu:t=>`https://www.hulu.com/search?q=${encodeURIComponent(t)}`,
  prime:t=>`https://www.amazon.com/s?k=${encodeURIComponent(t)}&i=instant-video`,
  disney:t=>`https://www.disneyplus.com/search?q=${encodeURIComponent(t)}`,
  max:t=>`https://play.max.com/search?q=${encodeURIComponent(t)}`,
  peacock:t=>`https://www.peacocktv.com/search?query=${encodeURIComponent(t)}`,
  paramount:t=>`https://www.paramountplus.com/shows/?searchTerm=${encodeURIComponent(t)}`,
  apple:t=>`https://tv.apple.com/us/search?term=${encodeURIComponent(t)}`,
};
const providerKeys = (item: ContentItem) => {
  const names = [
    ...(item.providers?.flatrate||[]), ...(item.providers?.ads||[]),
    ...(item.providers?.rent||[]), ...(item.providers?.buy||[])
  ].map(n => n.toLowerCase());
  const keys = new Set<string>();
  for (const n of names) for (const k in NAME_MAP) if (n.includes(k)) keys.add(NAME_MAP[k]);
  return Array.from(keys);
};


In your result card (inside CardContent), add just above the button:

<div className="flex flex-wrap gap-2 mb-3">
  {providerKeys(item).map(p => (
    <Badge key={p} variant="secondary" className="bg-black/60">{p}</Badge>
  ))}
</div>
{(() => {
  const prefFirst = providerKeys(item).find(p => preferences.services.includes(p)) || providerKeys(item)[0];
  return prefFirst ? (
    <Button asChild className="w-full bg-purple-600 hover:bg-purple-700" size="sm">
      <a href={WATCH_URL[prefFirst](item.title)} target="_blank" rel="noopener noreferrer">
        Open on {prefFirst}
        <ChevronRight className="ml-1 h-3 w-3" />
      </a>
    </Button>
  ) : null;
})()}

3) Environment + attribution

Add .env.local:

TMDB_API_KEY=your_tmdb_key
WATCH_REGION=US
OPENAI_API_KEY=sk-...           # optional
OPENAI_MODEL=gpt-4o-mini


Footer copy (required):
“This product uses the TMDb API but is not endorsed or certified by TMDb.”

4) Quick test

From your repo root, run:

npm run dev
# then in another terminal:
curl -sS -X POST http://localhost:3000/api/matchmaker/retrieve \
 -H "Content-Type: application/json" \
 -d '{"services":["netflix"],"timeWindow":120,"mediaTypes":["movie","tv"],"languages":["en-US"]}' | jq .


If you see { "error": "TMDB_API_KEY not set" } → set env + restart.

If you see items: [...] → UI will work.