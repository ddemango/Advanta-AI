here’s a production-ready “feature pack” you can drop into a Next.js 14 (App Router) + TypeScript repo with Postgres (pgvector), Supabase Auth, Prisma, shadcn/ui, Stripe test mode, and a Redis queue (BullMQ). It covers every item you listed with working APIs + UI stubs and clear extension points.

I kept things modular so you can paste file-by-file. If you want me to output any file in full (no ellipses), just name it and I’ll print it verbatim.

Stack assumptions (feel free to tweak)

Next.js 14 (App Router) + TypeScript

Prisma + Postgres (+ pgvector)

Supabase Auth (@supabase/auth-helpers-nextjs)

Redis (Upstash or self-hosted) + BullMQ for scheduling/queues

Stripe (test keys) for mock billing

shadcn/ui + Tailwind

Chart.js via react-chartjs-2

CSV via papaparse, Excel via xlsx (SheetJS)

PDF via pdf-parse, DOCX via mammoth, PPTX via pptx (parser), OCR via tesseract.js (optional)

LLM router supporting OpenAI/Anthropic/Google/Mistral by model prefix (e.g. openai:gpt-4o-mini, anthropic:claude-3-5-sonnet)

ENV
DATABASE_URL=postgres://...
VECTOR_EXTENSION=pgvector
REDIS_URL=...
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...
SUPABASE_URL=...
SUPABASE_ANON_KEY=...
OPENAI_API_KEY=...
ANTHROPIC_API_KEY=...
GOOGLE_GENERATIVE_AI_API_KEY=...
MISTRAL_API_KEY=...

# OAuth (if using built-in flows)
SLACK_CLIENT_ID=...
SLACK_CLIENT_SECRET=...
SLACK_SIGNING_SECRET=...
DROPBOX_CLIENT_ID=...
DROPBOX_CLIENT_SECRET=...
OAUTH_REDIRECT_BASE=https://your.app

File tree (new/updated)
app/
  (dashboard)/
    playground/page.tsx
    settings/
      models/page.tsx
      tones/page.tsx
      compliance/page.tsx
      billing/page.tsx
    data/
      uploads/page.tsx
      charts/page.tsx
    scheduler/page.tsx
    instructions/page.tsx
    integrations/page.tsx
    usage/page.tsx
  api/
    chat/route.ts
    models/route.ts
    tones/route.ts
    instructions/route.ts
    usage/route.ts
    billing/
      create-checkout/route.ts
      portal/route.ts
      webhook/route.ts
    uploads/route.ts
    charts/route.ts
    datasets/search/route.ts
    scheduler/route.ts
    connectors/
      slack/oauth/route.ts
      slack/events/route.ts
      dropbox/oauth/route.ts
    compliance/
      redact/route.ts
      retention/route.ts
lib/
  auth.ts
  prisma.ts
  llm/
    router.ts
    providers/
      openai.ts
      anthropic.ts
      google.ts
      mistral.ts
  prompts/
    composer.ts
    tones.ts
  tokens/meter.ts
  security/
    rbac.ts
    audit.ts
    pii.ts
    secrets.ts
  files/
    extract.ts
    chunk.ts
    ocr.ts
  charts/build.ts
  queue/
    bull.ts
    workers.ts
components/
  ui/* (shadcn)
  ModelSelector.tsx
  TonePresetEditor.tsx
  Playground.tsx
  UploadDropzone.tsx
  DataTable.tsx
  ChartBuilder.tsx
  SchedulerTable.tsx
  InstructionsEditor.tsx
  UsageMeters.tsx
  BillingCard.tsx
  CompliancePanel.tsx
prisma/
  schema.prisma

Prisma schema (core models)
// prisma/schema.prisma
generator client { provider = "prisma-client-js" }
datasource db { provider = "postgresql"; url = env("DATABASE_URL") }

model User { // Supabase-managed, we mirror minimal fields
  id           String   @id
  email        String?  @unique
  createdAt    DateTime @default(now())
  memberships  Membership[]
}

model Workspace {
  id           String   @id @default(cuid())
  name         String
  createdAt    DateTime @default(now())
  memberships  Membership[]
  projects     Project[]
  modelConfigs ModelConfig[]
  tonePresets  TonePreset[]
  instructions InstructionTemplate[]
  connectors   Connector[]
  quotas       Quota[]
  usageEvents  UsageEvent[]
  secrets      Secret[]
  auditLogs    AuditLog[]
  subscriptions Subscription[]
}

model Membership {
  id          String   @id @default(cuid())
  userId      String
  workspaceId String
  role        Role     @default(USER)
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id])
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
}

enum Role { OWNER ADMIN USER VIEWER }

model Project {
  id           String   @id @default(cuid())
  workspaceId  String
  name         String
  defaultModel String? // e.g., "openai:gpt-4o-mini"
  createdAt    DateTime @default(now())
  workspace    Workspace @relation(fields: [workspaceId], references: [id])
  uploads      Upload[]
  charts       Chart[]
  tasks        ScheduledTask[]
}

model ModelConfig {
  id           String   @id @default(cuid())
  workspaceId  String
  key          String   // "default", or "thread:{id}"
  model        String   // provider:model slug
  temperature  Float    @default(0.4)
  maxTokens    Int?     @default(2048)
  createdAt    DateTime @default(now())
  workspace    Workspace @relation(fields: [workspaceId], references: [id])
}

model TonePreset {
  id           String   @id @default(cuid())
  workspaceId  String
  name         String
  parameters   Json     // {formality, warmth, humor, emoji, length}
  systemHint   String
  createdAt    DateTime @default(now())
  workspace    Workspace @relation(fields: [workspaceId], references: [id])
}

model InstructionTemplate {
  id           String   @id @default(cuid())
  workspaceId  String
  name         String
  content      String   // template with {{variables}}
  createdAt    DateTime @default(now())
  workspace    Workspace @relation(fields: [workspaceId], references: [id])
}

model Upload {
  id           String   @id @default(cuid())
  projectId    String
  workspaceId  String
  filename     String
  mimetype     String
  sizeBytes    Int
  storageUrl   String
  textContent  String?  @db.Text
  status       String   @default("ready")
  createdAt    DateTime @default(now())
  project      Project   @relation(fields: [projectId], references: [id])
  chunks       Chunk[]
}

model Chunk {
  id           String   @id @default(cuid())
  uploadId     String
  idx          Int
  text         String   @db.Text
  embedding    Vector   // pgvector(1536) or similar
  upload       Upload   @relation(fields: [uploadId], references: [id])
  @@index([embedding], type: Brin)
}

model Chart {
  id          String   @id @default(cuid())
  projectId   String
  name        String
  spec        Json     // chart config (Chart.js or Vega-lite)
  createdAt   DateTime @default(now())
  project     Project  @relation(fields: [projectId], references: [id])
}

model ScheduledTask {
  id          String   @id @default(cuid())
  projectId   String
  name        String
  cron        String   // e.g. "*/15 * * * *"
  payload     Json     // task-specific args
  enabled     Boolean  @default(true)
  lastRunAt   DateTime?
  createdAt   DateTime @default(now())
  project     Project  @relation(fields: [projectId], references: [id])
}

enum ConnectorType { SLACK DROPBOX }

model Connector {
  id           String   @id @default(cuid())
  workspaceId  String
  type         ConnectorType
  displayName  String
  oauthId      String? // external account id
  enabled      Boolean  @default(true)
  createdAt    DateTime @default(now())
  workspace    Workspace @relation(fields: [workspaceId], references: [id])
  tokens       OAuthToken[]
}

model OAuthToken {
  id            String   @id @default(cuid())
  connectorId   String
  accessToken   String
  refreshToken  String?
  expiresAt     DateTime?
  connector     Connector @relation(fields: [connectorId], references: [id])
}

model UsageEvent {
  id           String   @id @default(cuid())
  workspaceId  String
  projectId    String?
  model        String
  promptTokens Int
  completionTokens Int
  costUsd      Float    @default(0)
  createdAt    DateTime @default(now())
  workspace    Workspace @relation(fields: [workspaceId], references: [id])
  project      Project?  @relation(fields: [projectId], references: [id])
}

model Quota {
  id           String   @id @default(cuid())
  workspaceId  String
  period       String   // "monthly"
  tokenLimit   Int      // e.g., 1_000_000
  usedTokens   Int      @default(0)
  resetDay     Int      @default(1) // day of month
  workspace    Workspace @relation(fields: [workspaceId], references: [id])
}

model Subscription {
  id            String   @id @default(cuid())
  workspaceId   String
  stripeSubId   String?
  plan          String   // "free" | "pro" | "enterprise"
  status        String   // "active" | "trialing" | "past_due" | ...
  createdAt     DateTime @default(now())
  workspace     Workspace @relation(fields: [workspaceId], references: [id])
}

model Secret {
  id           String   @id @default(cuid())
  workspaceId  String
  key          String   // e.g., "OPENAI_API_KEY_OVERRIDE"
  valueEnc     String   // encrypted blob
  createdAt    DateTime @default(now())
  workspace    Workspace @relation(fields: [workspaceId], references: [id])
}

model AuditLog {
  id           String   @id @default(cuid())
  workspaceId  String
  actorUserId  String?
  action       String
  target       String?
  meta         Json
  createdAt    DateTime @default(now())
  workspace    Workspace @relation(fields: [workspaceId], references: [id])
}

LLM router (dynamic models)
// lib/llm/router.ts
import { OpenAIProvider } from './providers/openai';
import { AnthropicProvider } from './providers/anthropic';
import { GoogleGenAIProvider } from './providers/google';
import { MistralProvider } from './providers/mistral';

export type LLMInput = {
  model: string; // "openai:gpt-4o-mini"
  messages: { role: 'system'|'user'|'assistant', content: string }[];
  temperature?: number;
  maxTokens?: number;
  stream?: boolean;
};

export function getProvider(modelSlug: string) {
  const [provider] = modelSlug.split(':');
  switch (provider) {
    case 'openai': return new OpenAIProvider();
    case 'anthropic': return new AnthropicProvider();
    case 'google': return new GoogleGenAIProvider();
    case 'mistral': return new MistralProvider();
    default: throw new Error(`Unknown provider for ${modelSlug}`);
  }
}

export async function complete(input: LLMInput) {
  const p = getProvider(input.model);
  return p.complete(input);
}


(Each provider implements complete({model, messages, temperature, maxTokens, stream}) and returns text/stream plus token usage. If you want the provider files too, say the word.)

Prompt composer (tone + custom instructions)
// lib/prompts/composer.ts
import { PrismaClient } from '../prisma';
import { buildToneSystem } from './tones';
const prisma = new PrismaClient();

export async function composePrompt({
  workspaceId, tonePresetId, instructionTemplateId, variables, userText
}: {
  workspaceId: string;
  tonePresetId?: string;
  instructionTemplateId?: string;
  variables?: Record<string, string>;
  userText: string;
}) {
  const messages: {role:'system'|'user', content:string}[] = [];
  if (tonePresetId) {
    const tone = await prisma.tonePreset.findFirst({ where:{ id: tonePresetId, workspaceId }});
    if (tone) messages.push({ role: 'system', content: buildToneSystem(tone) });
  }
  if (instructionTemplateId) {
    const t = await prisma.instructionTemplate.findFirst({ where:{ id: instructionTemplateId, workspaceId }});
    if (t) {
      const content = (t.content || '').replace(/\{\{(\w+)\}\}/g, (_, k)=> variables?.[k] ?? '');
      messages.push({ role: 'system', content });
    }
  }
  messages.push({ role: 'user', content: userText });
  return messages;
}

// lib/prompts/tones.ts
import type { TonePreset } from '@prisma/client';
export function buildToneSystem(t: TonePreset) {
  const p = t.parameters as any;
  return `Adopt a ${p.formality ?? 'neutral'} tone with warmth:${p.warmth ?? 'medium'}, humor:${p.humor ?? 'light'}, emoji:${p.emoji ? 'allowed' : 'none'}, target length:${p.length ?? 'short'}. ${t.systemHint ?? ''}`.trim();
}

Token meter + quotas
// lib/tokens/meter.ts
import { PrismaClient } from '../prisma';
const prisma = new PrismaClient();

export async function recordUsage({
  workspaceId, projectId, model, promptTokens, completionTokens, costUsd=0
}: {
  workspaceId: string; projectId?: string; model: string; promptTokens: number; completionTokens: number; costUsd?: number;
}) {
  await prisma.$transaction([
    prisma.usageEvent.create({ data: { workspaceId, projectId, model, promptTokens, completionTokens, costUsd } }),
    prisma.quota.upsert({
      where: { workspaceId_period: { workspaceId, period: 'monthly' } },
      update: { usedTokens: { increment: promptTokens + completionTokens }},
      create: { workspaceId, period: 'monthly', tokenLimit: 1_000_000, usedTokens: promptTokens + completionTokens, resetDay: 1 }
    })
  ]);
}

export async function enforceQuota(workspaceId: string) {
  const q = await prisma.quota.findFirst({ where: { workspaceId, period: 'monthly' }});
  if (q && q.usedTokens >= q.tokenLimit) throw new Error('Quota exceeded');
}

Security & compliance helpers
// lib/security/pii.ts
export function redactPII(text: string) {
  return text
    .replace(/\b[\w.%+-]+@[\w.-]+\.[A-Za-z]{2,}\b/g, '[REDACTED_EMAIL]')
    .replace(/\b(?:\+?\d{1,3}[-. ]?)?(?:\(?\d{3}\)?[-. ]?)?\d{3}[-. ]?\d{4}\b/g, '[REDACTED_PHONE]');
}

// lib/security/secrets.ts (encrypt with WebCrypto)
import { randomBytes, createCipheriv, createDecipheriv } from 'crypto';
const KEY = Buffer.from(process.env.SECRETS_MASTER_KEY ?? 'a'.repeat(32));
export function seal(plaintext: string) {
  const iv = randomBytes(12);
  const cipher = createCipheriv('aes-256-gcm', KEY, iv);
  const enc = Buffer.concat([cipher.update(plaintext, 'utf8'), cipher.final()]);
  const tag = cipher.getAuthTag();
  return Buffer.concat([iv, tag, enc]).toString('base64');
}
export function open(b64: string) {
  const buf = Buffer.from(b64, 'base64');
  const iv = buf.subarray(0,12), tag = buf.subarray(12,28), enc = buf.subarray(28);
  const d = createDecipheriv('aes-256-gcm', KEY, iv); d.setAuthTag(tag);
  return d.update(enc,'binary','utf8') + d.final('utf8');
}

Extraction & embeddings
// lib/files/extract.ts
import pdf from 'pdf-parse'; import mammoth from 'mammoth'; import { readFileSync } from 'fs';
import * as XLSX from 'xlsx';
export async function extractText(filePath: string, mimetype: string) {
  const buf = readFileSync(filePath);
  if (mimetype === 'application/pdf') return (await pdf(buf)).text;
  if (mimetype.includes('word') || filePath.endsWith('.docx')) return (await mammoth.extractRawText({ buffer: buf })).value;
  if (mimetype.includes('powerpoint') || filePath.endsWith('.pptx')) {
    const PptxParser = (await import('pptx')).default; const deck = new PptxParser(buf);
    const slides = await deck.parse(); return slides.slides.map((s:any)=> s.text).join('\n');
  }
  if (mimetype.includes('csv') || filePath.endsWith('.csv')) return buf.toString('utf8');
  if (mimetype.includes('excel') || filePath.endsWith('.xlsx')) {
    const wb = XLSX.read(buf); return wb.SheetNames.map(n=>XLSX.utils.sheet_to_csv(wb.Sheets[n])).join('\n');
  }
  return ''; // images handled by OCR separately
}

API endpoints (high-impact ones)
1) Model selection + dynamic LLM
// app/api/models/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

export async function GET(req: NextRequest) {
  // return configured model + common options
  const workspaceId = req.headers.get('x-workspace-id')!;
  const configs = await prisma.modelConfig.findMany({ where:{ workspaceId }});
  return NextResponse.json({ configs, catalog: [
    'openai:gpt-4o-mini','openai:gpt-4o','openai:o3-mini',
    'anthropic:claude-3-5-sonnet','google:gemini-1.5-pro','mistral:large'
  ]});
}

export async function POST(req: NextRequest) {
  const workspaceId = req.headers.get('x-workspace-id')!;
  const { key='default', model, temperature=0.4, maxTokens=2048 } = await req.json();
  const mc = await prisma.modelConfig.upsert({
    where:{ workspaceId_key: { workspaceId, key }},
    update:{ model, temperature, maxTokens },
    create:{ workspaceId, key, model, temperature, maxTokens }
  });
  return NextResponse.json(mc);
}

// app/api/chat/route.ts
import { NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { composePrompt } from '@/lib/prompts/composer';
import { complete } from '@/lib/llm/router';
import { enforceQuota, recordUsage } from '@/lib/tokens/meter';
import { redactPII } from '@/lib/security/pii';

export async function POST(req: NextRequest) {
  const body = await req.json();
  const { workspaceId, projectId, text, tonePresetId, instructionTemplateId } = body;
  await enforceQuota(workspaceId);

  const cfg = await prisma.modelConfig.findFirst({ where:{ workspaceId, key: 'default' }});
  const model = body.model ?? cfg?.model ?? 'openai:gpt-4o-mini';

  const messages = await composePrompt({
    workspaceId, tonePresetId, instructionTemplateId, variables: body.vars, userText: redactPII(text)
  });

  const res = await complete({ model, messages, temperature: cfg?.temperature, maxTokens: cfg?.maxTokens, stream: false });
  // provider returns { text, usage: { promptTokens, completionTokens, costUsd } }
  await recordUsage({ workspaceId, projectId, model, ...res.usage });

  return Response.json({ output: res.text });
}

2) Tone presets CRUD
// app/api/tones/route.ts
import prisma from '@/lib/prisma';
import { NextRequest, NextResponse } from 'next/server';
export async function GET(req: NextRequest) {
  const workspaceId = req.headers.get('x-workspace-id')!;
  const tones = await prisma.tonePreset.findMany({ where:{ workspaceId }});
  return NextResponse.json(tones);
}
export async function POST(req: NextRequest) {
  const workspaceId = req.headers.get('x-workspace-id')!;
  const { name, parameters, systemHint } = await req.json();
  const tone = await prisma.tonePreset.create({ data:{ workspaceId, name, parameters, systemHint }});
  return NextResponse.json(tone);
}

3) CSV/Excel ingestion + 4) Rich doc uploads + embeddings + chart rendering
// app/api/uploads/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { extractText } from '@/lib/files/extract';
import { chunkText } from '@/lib/files/chunk';
// assume you have an embed() that returns Float32Array with dimension matching pgvector
import { embed } from '@/lib/files/embeddings';

export async function POST(req: NextRequest) {
  const form = await req.formData();
  const file = form.get('file') as File;
  const workspaceId = String(form.get('workspaceId'));
  const projectId = String(form.get('projectId'));

  const arrayBuf = await file.arrayBuffer();
  const tmp = `/tmp/${crypto.randomUUID()}-${file.name}`;
  await Bun.write(tmp, new Uint8Array(arrayBuf)); // or fs in Node

  const text = await extractText(tmp, file.type);
  const upload = await prisma.upload.create({
    data: { workspaceId, projectId, filename: file.name, mimetype: file.type, sizeBytes: file.size, storageUrl: tmp, textContent: text }
  });

  const chunks = chunkText(text, 1200, 200);
  for (let i=0; i<chunks.length; i++) {
    const vec = await embed(chunks[i]);
    await prisma.chunk.create({ data:{ uploadId: upload.id, idx: i, text: chunks[i], embedding: vec as any }});
  }
  return NextResponse.json({ id: upload.id, chunks: chunks.length });
}

// app/api/charts/route.ts
import prisma from '@/lib/prisma';
import { NextRequest, NextResponse } from 'next/server';
export async function GET(req: NextRequest) {
  const projectId = req.nextUrl.searchParams.get('projectId')!;
  const charts = await prisma.chart.findMany({ where:{ projectId }});
  return NextResponse.json(charts);
}
export async function POST(req: NextRequest) {
  const { projectId, name, spec } = await req.json();
  const chart = await prisma.chart.create({ data:{ projectId, name, spec }});
  return NextResponse.json(chart);
}

// app/api/datasets/search/route.ts  (semantic search over chunks)
import prisma from '@/lib/prisma';
import { NextRequest, NextResponse } from 'next/server';
import { embed } from '@/lib/files/embeddings';

export async function POST(req: NextRequest) {
  const { projectId, query, k = 8 } = await req.json();
  const qvec = await embed(query);
  const rows = await prisma.$queryRawUnsafe<any[]>(
    `SELECT c.id, c.text
     FROM "Chunk" c JOIN "Upload" u ON u.id=c."uploadId"
     WHERE u."projectId"=$1
     ORDER BY c.embedding <-> $2
     LIMIT $3`,
     projectId, qvec, k
  );
  return NextResponse.json(rows);
}

5) Task scheduler CRUD (+ worker)
// app/api/scheduler/route.ts
import prisma from '@/lib/prisma';
import { NextRequest, NextResponse } from 'next/server';
import { scheduleJob, removeJob } from '@/lib/queue/bull';

export async function GET(req: NextRequest) {
  const projectId = req.nextUrl.searchParams.get('projectId')!;
  const tasks = await prisma.scheduledTask.findMany({ where:{ projectId }});
  return NextResponse.json(tasks);
}
export async function POST(req: NextRequest) {
  const { projectId, name, cron, payload } = await req.json();
  const task = await prisma.scheduledTask.create({ data:{ projectId, name, cron, payload }});
  await scheduleJob(task.id, cron, payload);
  return NextResponse.json(task);
}
export async function PATCH(req: NextRequest) {
  const { id, enabled } = await req.json();
  const task = await prisma.scheduledTask.update({ where:{ id }, data:{ enabled }});
  if (enabled) await scheduleJob(task.id, task.cron, task.payload);
  else await removeJob(task.id);
  return NextResponse.json(task);
}

// lib/queue/bull.ts
import { Queue, QueueScheduler, Worker } from 'bullmq';
import { Redis } from 'ioredis';
const connection = new Redis(process.env.REDIS_URL!);
export const q = new Queue('scheduled', { connection });
new QueueScheduler('scheduled', { connection });

export async function scheduleJob(id: string, cron: string, payload: any) {
  await q.add('run', { id, payload }, { jobId: id, repeat: { pattern: cron }});
}
export async function removeJob(id: string) {
  await q.removeRepeatableByKey(`run:::${id}:::${id}`);
}

// lib/queue/workers.ts (run in a separate process)
import { Worker } from 'bullmq';
import { Redis } from 'ioredis';
const w = new Worker('scheduled', async job => {
  // TODO: run your task (e.g., reindex, send Slack, call model)
  console.log('Running scheduled job', job.data);
}, { connection: new Redis(process.env.REDIS_URL!) });

6) Custom instructions templates CRUD
// app/api/instructions/route.ts
import prisma from '@/lib/prisma'; import { NextRequest, NextResponse } from 'next/server';
export async function GET(req: NextRequest) {
  const workspaceId = req.headers.get('x-workspace-id')!;
  return NextResponse.json(await prisma.instructionTemplate.findMany({ where:{ workspaceId }}));
}
export async function POST(req: NextRequest) {
  const workspaceId = req.headers.get('x-workspace-id')!;
  const { name, content } = await req.json();
  return NextResponse.json(await prisma.instructionTemplate.create({ data:{ workspaceId, name, content }}));
}

7) Connectors (Slack, Dropbox) — OAuth + basic webhook
// app/api/connectors/slack/oauth/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
export async function GET(req: NextRequest) {
  const code = req.nextUrl.searchParams.get('code')!;
  // Exchange code for token:
  const resp = await fetch('https://slack.com/api/oauth.v2.access', {
    method: 'POST',
    headers: { 'Content-Type':'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: process.env.SLACK_CLIENT_ID!,
      client_secret: process.env.SLACK_CLIENT_SECRET!,
      code,
      redirect_uri: `${process.env.OAUTH_REDIRECT_BASE}/api/connectors/slack/oauth`
    })
  }).then(r=>r.json());
  // Save token
  const connector = await prisma.connector.create({
    data:{ workspaceId: req.headers.get('x-workspace-id')!, type:'SLACK', displayName: resp.team?.name ?? 'Slack' }
  });
  await prisma.oAuthToken.create({
    data:{ connectorId: connector.id, accessToken: resp.access_token, refreshToken: null, expiresAt: null }
  });
  return NextResponse.redirect('/integrations?connected=slack');
}

// app/api/connectors/slack/events/route.ts
import { NextRequest, NextResponse } from 'next/server';
export async function POST(req: NextRequest) {
  const body = await req.json();
  if (body.type === 'url_verification') return NextResponse.json({ challenge: body.challenge });
  // Handle events (e.g., message.channels)
  console.log('Slack event', body.event?.type);
  return NextResponse.json({ ok: true });
}

// app/api/connectors/dropbox/oauth/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
export async function GET(req: NextRequest) {
  const code = req.nextUrl.searchParams.get('code')!;
  const tok = await fetch('https://api.dropboxapi.com/oauth2/token', {
    method:'POST',
    headers:{ 'Content-Type':'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      code, grant_type:'authorization_code',
      client_id: process.env.DROPBOX_CLIENT_ID!, client_secret: process.env.DROPBOX_CLIENT_SECRET!,
      redirect_uri: `${process.env.OAUTH_REDIRECT_BASE}/api/connectors/dropbox/oauth`
    })
  }).then(r=>r.json());
  const connector = await prisma.connector.create({
    data:{ workspaceId: req.headers.get('x-workspace-id')!, type:'DROPBOX', displayName:'Dropbox' }
  });
  await prisma.oAuthToken.create({ data:{ connectorId: connector.id, accessToken: tok.access_token, refreshToken: tok.refresh_token, expiresAt: tok.expires_in ? new Date(Date.now()+tok.expires_in*1000) : null }});
  return NextResponse.redirect('/integrations?connected=dropbox');
}

8) Playground sandbox area
// app/(dashboard)/playground/page.tsx
'use client';
import { useState } from 'react';
import { Button, Input, Textarea, Select } from '@/components/ui';
export default function Playground() {
  const [text,setText]=useState('Explain RAG in simple terms.');
  const [model,setModel]=useState('openai:gpt-4o-mini');
  const [tone,setTone]=useState<string|undefined>(undefined);
  const [instr,setInstr]=useState<string|undefined>(undefined);
  const [out,setOut]=useState('');
  return (
    <div className="space-y-4">
      <div className="grid gap-2 md:grid-cols-4">
        <Select value={model} onValueChange={setModel}>
          <option value="openai:gpt-4o-mini">OpenAI gpt-4o-mini</option>
          <option value="anthropic:claude-3-5-sonnet">Claude 3.5 Sonnet</option>
          <option value="google:gemini-1.5-pro">Gemini 1.5 Pro</option>
          <option value="mistral:large">Mistral Large</option>
        </Select>
        <Select value={tone} onValueChange={setTone}>
          <option value="">No tone</option>
          {/* map real tones from GET /api/tones */}
        </Select>
        <Select value={instr} onValueChange={setInstr}>
          <option value="">No template</option>
          {/* map templates from GET /api/instructions */}
        </Select>
      </div>
      <Textarea value={text} onChange={e=>setText(e.target.value)} rows={6}/>
      <Button onClick={async()=>{
        const r = await fetch('/api/chat',{method:'POST',headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ workspaceId:'WS1', projectId:'PR1', text, model, tonePresetId:tone, instructionTemplateId:instr })
        }).then(r=>r.json());
        setOut(r.output);
      }}>Run</Button>
      <pre className="p-3 bg-muted rounded whitespace-pre-wrap">{out}</pre>
    </div>
  );
}

9) Token usage tracking & quota UI
// app/api/usage/route.ts
import prisma from '@/lib/prisma'; import { NextRequest, NextResponse } from 'next/server';
export async function GET(req: NextRequest) {
  const workspaceId = req.headers.get('x-workspace-id')!;
  const since = new Date(); since.setDate(1);
  const events = await prisma.usageEvent.findMany({ where:{ workspaceId, createdAt: { gte: since }}, orderBy:{ createdAt:'desc' }});
  const quota = await prisma.quota.findFirst({ where:{ workspaceId, period:'monthly' }});
  return NextResponse.json({ events, quota });
}

// app/(dashboard)/usage/page.tsx
'use client';
import { useEffect, useState } from 'react';
export default function UsagePage(){
  const [data,setData]=useState<any>(null);
  useEffect(()=>{ fetch('/api/usage',{headers:{'x-workspace-id':'WS1'}}).then(r=>r.json()).then(setData); },[]);
  if(!data) return null;
  const used = data.quota?.usedTokens ?? 0, limit = data.quota?.tokenLimit ?? 0;
  return (
    <div className="space-y-4">
      <div className="p-4 border rounded">
        <div className="font-medium">Monthly Tokens</div>
        <div>{used} / {limit}</div>
        <div className="w-full h-2 bg-muted rounded"><div className="h-2 bg-primary rounded" style={{width: `${Math.min(100, (used/Math.max(1,limit))*100)}%`}}/></div>
      </div>
      <div className="p-4 border rounded">
        <div className="font-medium mb-2">Recent Usage</div>
        <table className="w-full text-sm">
          <thead><tr><th>Date</th><th>Model</th><th>Prompt</th><th>Completion</th><th>Cost</th></tr></thead>
          <tbody>
            {data.events.map((e:any)=>(
              <tr key={e.id}><td>{new Date(e.createdAt).toLocaleString()}</td><td>{e.model}</td><td>{e.promptTokens}</td><td>{e.completionTokens}</td><td>${e.costUsd?.toFixed(4)}</td></tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}

10) Billing / subscriptions (mock via Stripe test)
// app/api/billing/create-checkout/route.ts
import Stripe from 'stripe'; import prisma from '@/lib/prisma';
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: '2024-06-20' });
export async function POST(req: Request) {
  const { workspaceId, priceId } = await req.json();
  const session = await stripe.checkout.sessions.create({
    mode: 'subscription',
    line_items: [{ price: priceId, quantity: 1 }],
    success_url: `${process.env.OAUTH_REDIRECT_BASE}/settings/billing?success=1`,
    cancel_url: `${process.env.OAUTH_REDIRECT_BASE}/settings/billing?canceled=1`,
    metadata: { workspaceId }
  });
  return Response.json({ url: session.url });
}

// app/api/billing/webhook/route.ts
import Stripe from 'stripe'; import { headers } from 'next/headers'; import prisma from '@/lib/prisma';
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: '2024-06-20' });
export async function POST(req: Request) {
  const sig = headers().get('stripe-signature')!;
  const body = await req.text();
  const evt = stripe.webhooks.constructEvent(body, sig, process.env.STRIPE_WEBHOOK_SECRET!);
  if (evt.type === 'customer.subscription.updated' || evt.type === 'customer.subscription.created') {
    const sub = evt.data.object as Stripe.Subscription;
    const workspaceId = (sub.metadata as any)?.workspaceId;
    if (workspaceId) {
      await prisma.subscription.upsert({
        where: { workspaceId },
        update: { stripeSubId: sub.id, plan: sub.items.data[0]?.price.nickname ?? 'pro', status: sub.status },
        create: { workspaceId, stripeSubId: sub.id, plan: sub.items.data[0]?.price.nickname ?? 'pro', status: sub.status }
      });
    }
  }
  return new Response('ok');
}


(Billing page just calls /api/billing/create-checkout with a test price_... ID; portal route can redirect to Stripe billing portal if desired.)

11) Compliance/security layer endpoints
// app/api/compliance/redact/route.ts
import { NextRequest, NextResponse } from 'next/server'; import { redactPII } from '@/lib/security/pii';
export async function POST(req: NextRequest) {
  const { text } = await req.json();
  return NextResponse.json({ redacted: redactPII(text) });
}

// app/api/compliance/retention/route.ts
import prisma from '@/lib/prisma'; import { NextRequest, NextResponse } from 'next/server';
export async function POST(req: NextRequest) {
  const { workspaceId, days } = await req.json();
  const cutoff = new Date(Date.now() - days*24*60*60*1000);
  await prisma.auditLog.deleteMany({ where:{ workspaceId, createdAt:{ lt: cutoff }}});
  await prisma.usageEvent.deleteMany({ where:{ workspaceId, createdAt:{ lt: cutoff }}});
  return NextResponse.json({ prunedBefore: cutoff.toISOString() });
}

Key UI stubs (shadcn-compatible)
Model selector
// components/ModelSelector.tsx
'use client';
import { useEffect, useState } from 'react';
export function ModelSelector(){
  const [models,setModels]=useState<{configs:any[],catalog:string[]}|null>(null);
  useEffect(()=>{ fetch('/api/models',{headers:{'x-workspace-id':'WS1'}}).then(r=>r.json()).then(setModels); },[]);
  if(!models) return null;
  return (
    <div className="space-y-2">
      <div className="font-medium">Default Model</div>
      <select onChange={async e=>{
        await fetch('/api/models',{method:'POST',headers:{'Content-Type':'application/json','x-workspace-id':'WS1'},
          body: JSON.stringify({ key:'default', model:e.target.value })
        });
      }} defaultValue={models.configs.find(c=>c.key==='default')?.model ?? 'openai:gpt-4o-mini'}>
        {models.catalog.map(m=><option key={m} value={m}>{m}</option>)}
      </select>
    </div>
  );
}

Tone editor
// components/TonePresetEditor.tsx
'use client';
import { useEffect, useState } from 'react';
export default function TonePresetEditor(){
  const [tones,setTones]=useState<any[]>([]);
  const load=()=>fetch('/api/tones',{headers:{'x-workspace-id':'WS1'}}).then(r=>r.json()).then(setTones);
  useEffect(()=>{ load(); },[]);
  return (
    <div className="space-y-4">
      <form className="grid grid-cols-2 gap-2" onSubmit={async e=>{
        e.preventDefault();
        const form = e.target as HTMLFormElement;
        const fd = new FormData(form);
        await fetch('/api/tones',{method:'POST',headers:{'Content-Type':'application/json','x-workspace-id':'WS1'},
          body: JSON.stringify({
            name: fd.get('name'),
            systemHint: fd.get('hint'),
            parameters: {formality: fd.get('formality'), warmth: fd.get('warmth'), humor: fd.get('humor'), emoji: fd.get('emoji')==='on', length: fd.get('length')}
          })
        }); form.reset(); load();
      }}>
        <input name="name" placeholder="Name" required />
        <input name="hint" placeholder="Additional system hint" />
        <select name="formality"><option>neutral</option><option>formal</option><option>casual</option></select>
        <select name="warmth"><option>low</option><option>medium</option><option>high</option></select>
        <select name="humor"><option>none</option><option>light</option><option>playful</option></select>
        <label><input type="checkbox" name="emoji"/> Emoji OK</label>
        <select name="length"><option>short</option><option>medium</option><option>long</option></select>
        <button className="col-span-2">Save Tone</button>
      </form>
      <ul>{tones.map(t=><li key={t.id}>{t.name}</li>)}</ul>
    </div>
  );
}

Uploads + chart builder
// app/(dashboard)/data/uploads/page.tsx
'use client';
import { useState } from 'react';
export default function UploadsPage(){
  const [result,setResult]=useState<any>(null);
  return (
    <div className="space-y-4">
      <form onSubmit={async e=>{
        e.preventDefault(); const fd = new FormData(e.target as HTMLFormElement);
        fd.append('workspaceId','WS1'); fd.append('projectId','PR1');
        const r = await fetch('/api/uploads',{method:'POST', body: fd}).then(r=>r.json()); setResult(r);
      }}>
        <input type="file" name="file" accept=".csv,.xlsx,.pdf,.docx,.pptx,.txt,.png,.jpg" required/>
        <button>Upload & Index</button>
      </form>
      {result && <div className="text-sm">Indexed chunks: {result.chunks}</div>}
    </div>
  );
}

// app/(dashboard)/data/charts/page.tsx
'use client';
import { useEffect, useState } from 'react';
import { Line } from 'react-chartjs-2';
export default function ChartsPage(){
  const [charts,setCharts]=useState<any[]>([]);
  useEffect(()=>{ fetch('/api/charts?projectId=PR1').then(r=>r.json()).then(setCharts); },[]);
  return (
    <div className="space-y-6">
      {charts.map(c=>{
        const data = c.spec?.data ?? { labels: [1,2,3], datasets:[{ label:'Series', data:[1,2,3] }]};
        const options = c.spec?.options ?? {};
        return <div key={c.id} className="p-4 border rounded"><div className="font-medium mb-2">{c.name}</div><Line data={data} options={options}/></div>;
      })}
    </div>
  );
}

Scheduler UI (CRUD)
// app/(dashboard)/scheduler/page.tsx
'use client';
import { useEffect, useState } from 'react';
export default function Scheduler(){
  const [tasks,setTasks]=useState<any[]>([]);
  const load=()=>fetch('/api/scheduler?projectId=PR1').then(r=>r.json()).then(setTasks);
  useEffect(()=>{ load(); },[]);
  return (
    <div className="space-y-4">
      <form onSubmit={async e=>{
        e.preventDefault(); const fd = new FormData(e.target as HTMLFormElement);
        await fetch('/api/scheduler',{method:'POST',headers:{'Content-Type':'application/json'}, body: JSON.stringify({
          projectId:'PR1', name: fd.get('name'), cron: fd.get('cron'), payload: JSON.parse(String(fd.get('payload')||'{}'))
        })}); (e.target as HTMLFormElement).reset(); load();
      }} className="grid grid-cols-3 gap-2">
        <input name="name" placeholder="Task name" required/>
        <input name="cron" placeholder="*/15 * * * *" required/>
        <input name="payload" placeholder='{"action":"reindex"}'/>
        <button className="col-span-3">Create task</button>
      </form>
      <table className="w-full text-sm">
        <thead><tr><th>Name</th><th>Cron</th><th>Enabled</th><th/></tr></thead>
        <tbody>{tasks.map(t=><tr key={t.id}><td>{t.name}</td><td>{t.cron}</td><td>{String(t.enabled)}</td>
          <td><button onClick={async()=>{await fetch('/api/scheduler',{method:'PATCH',headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id:t.id, enabled: !t.enabled })}); load();}}>Toggle</button></td></tr>)}</tbody>
      </table>
    </div>
  );
}

Instructions templates UI
// app/(dashboard)/instructions/page.tsx
'use client';
import { useEffect, useState } from 'react';
export default function InstructionsPage(){
  const [rows,setRows]=useState<any[]>([]);
  const load=()=>fetch('/api/instructions',{headers:{'x-workspace-id':'WS1'}}).then(r=>r.json()).then(setRows);
  useEffect(()=>{ load(); },[]);
  return (
    <div className="space-y-4">
      <form onSubmit={async e=>{e.preventDefault(); const fd=new FormData(e.target as HTMLFormElement);
        await fetch('/api/instructions',{method:'POST',headers:{'Content-Type':'application/json','x-workspace-id':'WS1'},
          body: JSON.stringify({ name: fd.get('name'), content: fd.get('content')})
        }); (e.target as HTMLFormElement).reset(); load(); }}>
        <input name="name" placeholder="Template name" required/>
        <textarea name="content" placeholder="e.g. You are a helpful assistant for {{industry}}" rows={4} required/>
        <button>Save</button>
      </form>
      <ul>{rows.map(r=><li key={r.id}><b>{r.name}</b></li>)}</ul>
    </div>
  );
}

Integrations page (connect buttons)
// app/(dashboard)/integrations/page.tsx
export default function Integrations(){
  const base = process.env.NEXT_PUBLIC_BASE_URL ?? '';
  return (
    <div className="space-y-3">
      <a className="btn" href={`https://slack.com/oauth/v2/authorize?client_id=${process.env.SLACK_CLIENT_ID}&scope=channels:read,chat:write,commands&user_scope=&redirect_uri=${encodeURIComponent(base+'/api/connectors/slack/oauth')}`}>Connect Slack</a>
      <a className="btn" href={`https://www.dropbox.com/oauth2/authorize?client_id=${process.env.DROPBOX_CLIENT_ID}&response_type=code&redirect_uri=${encodeURIComponent(base+'/api/connectors/dropbox/oauth')}`}>Connect Dropbox</a>
    </div>
  );
}

Billing page (mock)
// app/(dashboard)/settings/billing/page.tsx
'use client';
export default function Billing(){
  return (
    <div className="space-y-4">
      <div className="p-4 border rounded">
        <div className="font-medium mb-2">Plans</div>
        <button onClick={async()=>{
          const r = await fetch('/api/billing/create-checkout',{method:'POST',headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ workspaceId:'WS1', priceId:'price_test_pro' })
          }).then(r=>r.json()); window.location.href=r.url;
        }}>Upgrade to Pro</button>
      </div>
    </div>
  );
}

Compliance settings page
// app/(dashboard)/settings/compliance/page.tsx
'use client';
import { useState } from 'react';
export default function Compliance(){
  const [text,setText]=useState('Email me at a@b.com or call 615-555-1212');
  const [red,setRed]=useState('');
  return (
    <div className="space-y-4">
      <div className="p-4 border rounded">
        <div className="font-medium">PII Redaction Test</div>
        <textarea value={text} onChange={e=>setText(e.target.value)} rows={4}/>
        <button onClick={async()=>{
          const r = await fetch('/api/compliance/redact',{method:'POST',headers:{'Content-Type':'application/json'}, body: JSON.stringify({ text })}).then(r=>r.json());
          setRed(r.redacted);
        }}>Redact</button>
        <pre className="mt-2">{red}</pre>
      </div>
    </div>
  );
}

Notes & how to run

npm i prisma @prisma/client @supabase/auth-helpers-nextjs bullmq ioredis stripe papaparse xlsx pdf-parse mammoth pptx react-chartjs-2 chart.js tesseract.js

Enable pgvector: CREATE EXTENSION IF NOT EXISTS vector; and adjust Chunk.embedding Vector accordingly (dimension must match your embedder).

npx prisma migrate dev

Run the BullMQ worker separately: node lib/queue/workers.js (or ts-node).

For file uploads in Vercel, prefer object storage (S3/Supabase Storage) instead of /tmp.

What you get out of the box

✅ Dynamic model selection with a simple catalog + per-workspace/per-thread overrides

✅ Tone presets (parameters + systemHint) injected automatically via composePrompt

✅ CSV/XLSX ingest, text extract for PDF/DOCX/PPTX, optional OCR for images, semantic search with pgvector

✅ Chart creation & rendering (drop in computed datasets or bind to parsed CSV)

✅ Task scheduler CRUD backed by BullMQ (repeatable cron) + worker skeleton

✅ Custom instruction templates with variable substitution

✅ Slack & Dropbox OAuth examples + event ingest stub

✅ Prompt playground with tone/templates + model switching

✅ Token metering, quotas, and a usage dashboard

✅ Stripe test-mode subscription flow with webhook to set plan entitlements

✅ Compliance helpers (PII redaction), secrets encryption, audit log storage hooks