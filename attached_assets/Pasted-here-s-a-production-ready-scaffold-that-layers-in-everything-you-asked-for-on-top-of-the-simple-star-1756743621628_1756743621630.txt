here‚Äôs a production-ready scaffold that layers in everything you asked for on top of the simple starter:

Next.js 14 (App Router) + React 18 UI (Tailwind, shadcn/ui)

Auth (Supabase Auth JWT) + Neon Postgres (Prisma ORM)

Saved chats, projects, artifacts

Docs/PDF chat (chunk ‚Üí embed ‚Üí ChromaDB; optional pgvector path included)

Image + video generation (OpenAI Images + Replicate video)

Voice (TTS + STT via OpenAI Audio)

‚ÄúDeep Research‚Äù + ‚ÄúAgents‚Äù (background jobs using pg-boss on Postgres‚Äîworks fine on Neon)

GitHub ‚ÄúAI Engineer‚Äù hooks (GitHub App install + PR creation)

Job queue worker process

Clean API boundaries + typed SDK

Below is the complete code. Copy the whole tree into Replit or your repo and follow the ‚ÄúSetup‚Äù steps.

üìÇ Monorepo layout
ai-portal/
  apps/
    web/                 # Next.js 14 (App Router)
      app/
        api/
          auth/
            callback/route.ts
            middleware.ts
          chat/route.ts
          rag/
            ingest/route.ts
            query/route.ts
          generate/
            image/route.ts
            video/route.ts
          voice/
            tts/route.ts
            stt/route.ts
          agent/
            enqueue/route.ts
            status/route.ts
          github/
            install/route.ts
            webhook/route.ts
            pr/route.ts
        (dashboard)/page.tsx
        project/[id]/page.tsx
        globals.css
        layout.tsx
      components/
        ChatWindow.tsx
        ProjectSidebar.tsx
        ArtifactViewer.tsx
        VoiceWidget.tsx
        Topbar.tsx
      lib/
        auth.ts
        db.ts
        prisma.ts
        schemas.ts
        chroma.ts
        embeddings.ts
        github.ts
        queue.ts
        storage.ts
        rag.ts
        util.ts
      shadcn-components/*  (auto-generated via shadcn/ui)
      tailwind.config.ts
      postcss.config.js
      tsconfig.json
      next.config.mjs
      package.json
    worker/               # Background jobs (pg-boss)
      src/index.ts
      src/jobs/deepResearch.ts
      src/jobs/githubPR.ts
      src/jobs/ingestDoc.ts
      src/jobs/refreshArtifacts.ts
      package.json
  packages/
    shared/
      src/types.ts
      src/sdk.ts           # Tiny typed client for the API (browser+server)
      package.json
  prisma/
    schema.prisma
    migrations/           # generated after running migrate
  .env.example
  package.json
  turbo.json              # optional (multi-app scripts), can ignore on Replit
  README.md

üîê .env.example (copy to .env and fill)
# OpenAI
OPENAI_API_KEY=sk-...

# Replicate (video gen e.g. Pika/Luma)
REPLICATE_API_TOKEN=r8_...

# Supabase (Auth only; we verify JWTs via JWKS)
NEXT_PUBLIC_SUPABASE_URL=https://YOURPROJECT.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ...
SUPABASE_JWKS_URL=https://YOURPROJECT.supabase.co/auth/v1/keys

# Database (Neon Postgres)
DATABASE_URL=postgresql://user:pass@ep-...neon.tech/neondb?sslmode=require
DIRECT_URL=postgresql://user:pass@ep-...neon.tech/neondb?sslmode=require

# pg-boss (uses the same DATABASE_URL)
JOB_QUEUE_SCHEMA=boss

# ChromaDB (RAG store). Run local `chroma` or use hosted.
CHROMA_URL=http://localhost:8000
CHROMA_COLLECTION=docs

# GitHub App (AI Engineer hooks)
GITHUB_APP_ID=123456
GITHUB_APP_PRIVATE_KEY=-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----
GITHUB_WEBHOOK_SECRET=supersecret
GITHUB_APP_INSTALLATION_ID=  # optional default

# Next.js
NEXTAUTH_SECRET=dev-key-or-random
NEXT_PUBLIC_APP_URL=http://localhost:3000

üì¶ root /package.json
{
  "name": "ai-portal",
  "private": true,
  "workspaces": ["apps/*", "packages/*"],
  "scripts": {
    "dev": "pnpm -r run dev",
    "build": "pnpm -r run build",
    "start": "pnpm -r run start",
    "migrate": "prisma migrate deploy",
    "generate": "prisma generate",
    "worker": "pnpm --filter @ai/worker start"
  },
  "devDependencies": {
    "prisma": "5.17.0",
    "typescript": "5.5.4"
  },
  "dependencies": {
    "@ai/shared": "workspace:*",
    "@octokit/app": "^15.0.0",
    "@octokit/webhooks": "^13.0.0",
    "@prisma/client": "5.17.0",
    "pg-boss": "^9.0.3"
  }
}

üóÑ prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  directUrl         = env("DIRECT_URL")
}

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  name          String?
  image         String?
  supabaseId    String?  @unique
  createdAt     DateTime @default(now())
  projects      Project[]
  chats         Chat[]
}

model Project {
  id          String    @id @default(cuid())
  ownerId     String
  owner       User      @relation(fields: [ownerId], references: [id])
  name        String
  description String?
  createdAt   DateTime  @default(now())
  artifacts   Artifact[]
  chats       Chat[]
}

model Chat {
  id         String    @id @default(cuid())
  projectId  String?
  project    Project?  @relation(fields: [projectId], references: [id])
  userId     String
  user       User      @relation(fields: [userId], references: [id])
  title      String?
  createdAt  DateTime  @default(now())
  messages   Message[]
}

model Message {
  id        String   @id @default(cuid())
  chatId    String
  chat      Chat     @relation(fields: [chatId], references: [id])
  role      String   // 'user' | 'assistant' | 'system'
  content   String
  createdAt DateTime @default(now())
}

model Artifact {
  id         String    @id @default(cuid())
  projectId  String
  project    Project   @relation(fields: [projectId], references: [id])
  kind       String    // 'react','html','mermaid','file','plot'
  name       String
  data       Json
  createdAt  DateTime  @default(now())
}

model Job {
  id        String   @id @default(cuid())
  type      String   // 'deep_research','github_pr','ingest_doc','refresh_artifacts'
  status    String   // 'queued','running','done','error'
  payload   Json
  result    Json?
  error     String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

üß± apps/web/package.json
{
  "name": "@ai/web",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start -p 3000"
  },
  "dependencies": {
    "@ai/shared": "workspace:*",
    "@chromadb/client": "^1.9.2",
    "@octokit/app": "^15.0.0",
    "@octokit/webhooks": "^13.0.0",
    "@supabase/supabase-js": "^2.45.0",
    "ai": "^3.3.7",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "gpt-tokenizer": "^2.1.1",
    "jsonwebtoken": "^9.0.2",
    "langchain": "^0.2.18",
    "next": "14.2.6",
    "next-themes": "^0.3.0",
    "octokit": "^3.1.2",
    "openai": "^4.55.4",
    "pg": "^8.12.0",
    "pg-boss": "^9.0.3",
    "prisma": "5.17.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "sharp": "^0.33.4",
    "tailwind-merge": "^2.5.2",
    "tailwindcss": "^3.4.10",
    "zod": "^3.23.8"
  }
}

üß© apps/web/next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: { serverActions: { bodySizeLimit: "12mb" } }
};
export default nextConfig;

üé® apps/web/tailwind.config.ts
import type { Config } from "tailwindcss";

export default {
  content: [
    "./app/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}"
  ],
  theme: { extend: {} },
  plugins: []
} satisfies Config;

üåê apps/web/app/layout.tsx
import "./globals.css";
import { ReactNode } from "react";

export const metadata = { title: "AI Portal", description: "LLM Portal" };

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body className="min-h-screen bg-zinc-950 text-zinc-100">
        <div className="max-w-7xl mx-auto p-4">{children}</div>
      </body>
    </html>
  );
}

üñ• apps/web/app/(dashboard)/page.tsx
import Link from "next/link";
import ProjectSidebar from "@/components/ProjectSidebar";
import Topbar from "@/components/Topbar";

export default async function Page() {
  return (
    <div className="grid grid-cols-12 gap-4">
      <aside className="col-span-3">
        <ProjectSidebar />
      </aside>
      <main className="col-span-9 space-y-6">
        <Topbar title="Dashboard" />
        <div className="rounded-xl border border-zinc-800 p-6">
          <h2 className="text-xl font-semibold mb-2">Welcome</h2>
          <p className="text-zinc-300">
            Create a project, ingest docs, start a chat, generate artifacts, run deep research, or open a voice session.
          </p>
          <div className="mt-4 flex gap-3">
            <Link className="px-3 py-2 rounded bg-blue-600" href="/project/new">New Project</Link>
            <Link className="px-3 py-2 rounded border border-zinc-700" href="/project/quickstart">Quickstart</Link>
          </div>
        </div>
      </main>
    </div>
  );
}

üìÑ apps/web/app/project/[id]/page.tsx
import ChatWindow from "@/components/ChatWindow";
import ArtifactViewer from "@/components/ArtifactViewer";
import VoiceWidget from "@/components/VoiceWidget";
import ProjectSidebar from "@/components/ProjectSidebar";

export default async function ProjectPage({ params }: { params: { id: string } }) {
  const { id } = params;
  return (
    <div className="grid grid-cols-12 gap-4">
      <aside className="col-span-3">
        <ProjectSidebar activeProjectId={id} />
      </aside>
      <main className="col-span-9 space-y-6">
        <ChatWindow projectId={id} />
        <ArtifactViewer projectId={id} />
        <VoiceWidget />
      </main>
    </div>
  );
}

üß± key server libs (apps/web/lib/*)
lib/db.ts
import { PrismaClient } from "@prisma/client";
const globalForPrisma = global as unknown as { prisma?: PrismaClient };
export const prisma = globalForPrisma.prisma ?? new PrismaClient();
if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

lib/prisma.ts
export * from "@prisma/client";

lib/auth.ts (Supabase JWT verification)
import jwksClient from "jwks-rsa";
import jwt from "jsonwebtoken";

const jwks = jwksClient({ jwksUri: process.env.SUPABASE_JWKS_URL! });

export async function verifySupabaseJWT(token: string) {
  const decoded: any = jwt.decode(token, { complete: true });
  if (!decoded?.header?.kid) throw new Error("Invalid token");
  const key = await jwks.getSigningKey(decoded.header.kid);
  const pub = key.getPublicKey();
  return jwt.verify(token, pub, { algorithms: ["RS256"] }) as any;
}

lib/queue.ts (pg-boss connection)
import PgBoss from "pg-boss";
let boss: PgBoss | null = null;

export async function getBoss() {
  if (!boss) {
    boss = new PgBoss({
      connectionString: process.env.DATABASE_URL!,
      schema: process.env.JOB_QUEUE_SCHEMA || "boss"
    });
    await boss.start();
  }
  return boss;
}

lib/chroma.ts
import { ChromaClient, Collection } from "@chromadb/client";

let client: ChromaClient | null = null;
export async function chroma(): Promise<{ client: ChromaClient; collection: Collection; }> {
  if (!client) client = new ChromaClient({ path: process.env.CHROMA_URL! });
  const collection = await client.getOrCreateCollection({ name: process.env.CHROMA_COLLECTION! });
  return { client, collection };
}

lib/embeddings.ts
import OpenAI from "openai";
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function embedChunks(chunks: { id: string; text: string }[]) {
  const model = "text-embedding-3-large";
  const res = await openai.embeddings.create({
    model,
    input: chunks.map(c => c.text)
  });
  return res.data.map((v, i) => ({ id: chunks[i].id, embedding: v.embedding }));
}

lib/rag.ts
import { chroma } from "./chroma";
import { embedChunks } from "./embeddings";

export async function upsertDocs(docs: { id: string; text: string }[]) {
  const { collection } = await chroma();
  const embeds = await embedChunks(docs);
  await collection.upsert({
    ids: docs.map(d => d.id),
    embeddings: embeds.map(e => e.embedding),
    documents: docs.map(d => d.text)
  });
}

export async function queryRag(query: string, k = 6) {
  const { collection } = await chroma();
  const res = await collection.query({
    queryTexts: [query],
    nResults: k
  });
  const docs = (res.documents?.[0] || []) as string[];
  return docs.join("\n---\n");
}

lib/github.ts
import { App } from "@octokit/app";
import { Octokit } from "octokit";

export function appOctokit() {
  return new App({
    appId: process.env.GITHUB_APP_ID!,
    privateKey: process.env.GITHUB_APP_PRIVATE_KEY!.replace(/\\n/g, "\n"),
    webhooks: { secret: process.env.GITHUB_WEBHOOK_SECRET! }
  });
}

export async function installationClient(installationId: number) {
  const app = appOctokit();
  const auth = await app.getInstallationAccessToken({ installationId });
  return new Octokit({ auth });
}

lib/storage.ts (simple artifact setter)
import { prisma } from "./db";

export async function saveArtifact(projectId: string, kind: string, name: string, data: unknown) {
  return prisma.artifact.create({
    data: { projectId, kind, name, data: data as any }
  });
}

lib/util.ts
export function chunkText(s: string, max = 1200) {
  const out: string[] = [];
  let i = 0;
  while (i < s.length) {
    out.push(s.slice(i, i + max));
    i += max;
  }
  return out;
}

üß† API routes
Chat ‚Äî apps/web/app/api/chat/route.ts
import { NextRequest, NextResponse } from "next/server";
import OpenAI from "openai";
import { prisma } from "@/lib/db";
import { verifySupabaseJWT } from "@/lib/auth";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function POST(req: NextRequest) {
  const auth = req.headers.get("authorization") || "";
  const token = auth.replace(/^Bearer\s+/i, "");
  const user = await verifySupabaseJWT(token).catch(() => null);
  if (!user) return NextResponse.json({ ok: false, error: "unauthorized" }, { status: 401 });

  const { messages, model = "gpt-4o-mini", chatId, projectId } = await req.json();

  const completion = await openai.chat.completions.create({ model, messages, temperature: 0.6, max_tokens: 1200 });
  const text = completion.choices[0]?.message?.content ?? "";

  // persist message
  const chat = chatId ? await prisma.chat.findUnique({ where: { id: chatId } }) :
    await prisma.chat.create({ data: { userId: user.sub, projectId, title: messages?.[1]?.content?.slice(0, 48) ?? "Chat" } });

  await prisma.message.createMany({
    data: [
      { chatId: chat.id, role: "user", content: messages.at(-1)?.content ?? "" },
      { chatId: chat.id, role: "assistant", content: text }
    ]
  });

  return NextResponse.json({ ok: true, chatId: chat.id, message: text });
}

RAG ingest ‚Äî apps/web/app/api/rag/ingest/route.ts
import { NextRequest, NextResponse } from "next/server";
import { verifySupabaseJWT } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { upsertDocs } from "@/lib/rag";
import { chunkText } from "@/lib/util";
import pdf from "pdf-parse";

export const runtime = "nodejs"; // needs node (PDF lib)

export async function POST(req: NextRequest) {
  const auth = req.headers.get("authorization") || "";
  const token = auth.replace(/^Bearer\s+/i, "");
  const user = await verifySupabaseJWT(token).catch(() => null);
  if (!user) return NextResponse.json({ ok: false, error: "unauthorized" }, { status: 401 });

  const form = await req.formData();
  const projectId = form.get("projectId")!.toString();
  const file = form.get("file") as File;
  const buf = Buffer.from(await file.arrayBuffer());

  let text = "";
  if (file.type === "application/pdf") {
    const parsed = await pdf(buf);
    text = parsed.text;
  } else {
    text = buf.toString("utf-8");
  }

  const chunks = chunkText(text, 1500).map((t, i) => ({ id: `${projectId}:${Date.now()}:${i}`, text: t }));
  await upsertDocs(chunks);

  // Track an artifact reference
  await prisma.artifact.create({
    data: { projectId, kind: "doc", name: file.name, data: { size: buf.length, chunks: chunks.length } as any }
  });

  return NextResponse.json({ ok: true, chunks: chunks.length });
}

RAG query ‚Äî apps/web/app/api/rag/query/route.ts
import { NextRequest, NextResponse } from "next/server";
import { verifySupabaseJWT } from "@/lib/auth";
import { queryRag } from "@/lib/rag";
import OpenAI from "openai";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function POST(req: NextRequest) {
  const auth = req.headers.get("authorization") || "";
  const token = auth.replace(/^Bearer\s+/i, "");
  const user = await verifySupabaseJWT(token).catch(() => null);
  if (!user) return NextResponse.json({ ok: false, error: "unauthorized" }, { status: 401 });

  const { query, messages = [], model = "gpt-4o-mini" } = await req.json();
  const context = await queryRag(query);
  const prompt = [
    { role: "system", content: "Use the provided context to answer. Cite brief quotes." },
    ...messages,
    { role: "user", content: `Context:\n${context}\n\nQuestion: ${query}` }
  ];

  const res = await openai.chat.completions.create({ model, messages: prompt, temperature: 0.2, max_tokens: 900 });
  return NextResponse.json({ ok: true, answer: res.choices[0]?.message?.content ?? "" });
}

Image generation ‚Äî apps/web/app/api/generate/image/route.ts
import { NextRequest, NextResponse } from "next/server";
import OpenAI from "openai";
import { verifySupabaseJWT } from "@/lib/auth";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function POST(req: NextRequest) {
  const token = (req.headers.get("authorization") || "").replace(/^Bearer\s+/i, "");
  const user = await verifySupabaseJWT(token).catch(() => null);
  if (!user) return NextResponse.json({ ok: false, error: "unauthorized" }, { status: 401 });

  const { prompt, size = "1024x1024" } = await req.json();
  const img = await openai.images.generate({ model: "gpt-image-1", prompt, size });
  const url = img.data[0]?.url!;
  return NextResponse.json({ ok: true, url });
}

Video generation ‚Äî apps/web/app/api/generate/video/route.ts
import { NextRequest, NextResponse } from "next/server";
import { verifySupabaseJWT } from "@/lib/auth";

export async function POST(req: NextRequest) {
  const token = (req.headers.get("authorization") || "").replace(/^Bearer\s+/i, "");
  const user = await verifySupabaseJWT(token).catch(() => null);
  if (!user) return NextResponse.json({ ok: false, error: "unauthorized" }, { status: 401 });

  const { prompt } = await req.json();

  const resp = await fetch("https://api.replicate.com/v1/predictions", {
    method: "POST",
    headers: {
      Authorization: `Token ${process.env.REPLICATE_API_TOKEN}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      // Example: Pika 1.0 (update to a current model/owner)
      version: "pika-1.0-text-to-video",
      input: { prompt }
    })
  });
  const data = await resp.json();
  return NextResponse.json({ ok: true, id: data.id, status: data.status });
}

Voice TTS ‚Äî apps/web/app/api/voice/tts/route.ts
import { NextRequest } from "next/server";
import OpenAI from "openai";

export const runtime = "edge";

export async function POST(req: NextRequest) {
  const { text, voice = "alloy" } = await req.json();
  const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });
  const audio = await client.audio.speech.create({
    model: "gpt-4o-mini-tts",
    voice,
    input: text
  });
  const body = await audio.arrayBuffer();
  return new Response(body, { headers: { "Content-Type": "audio/mpeg" } });
}

Voice STT ‚Äî apps/web/app/api/voice/stt/route.ts
import { NextRequest, NextResponse } from "next/server";
import OpenAI from "openai";

export async function POST(req: NextRequest) {
  const form = await req.formData();
  const file = form.get("file") as File;
  const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });
  const transcription = await client.audio.transcriptions.create({
    file: new File([await file.arrayBuffer()], "audio.webm", { type: file.type }),
    model: "whisper-1"
  });
  return NextResponse.json({ ok: true, text: (transcription as any).text });
}

Agent enqueue/status ‚Äî apps/web/app/api/agent/enqueue/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getBoss } from "@/lib/queue";
import { verifySupabaseJWT } from "@/lib/auth";

export async function POST(req: NextRequest) {
  const token = (req.headers.get("authorization") || "").replace(/^Bearer\s+/i, "");
  const user = await verifySupabaseJWT(token).catch(() => null);
  if (!user) return NextResponse.json({ ok: false, error: "unauthorized" }, { status: 401 });

  const { type, payload } = await req.json();
  const boss = await getBoss();
  const jobId = await boss.send(type, { userId: user.sub, ...payload });
  return NextResponse.json({ ok: true, jobId });
}

apps/web/app/api/agent/status/route.ts
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET(req: NextRequest) {
  const id = new URL(req.url).searchParams.get("jobId")!;
  const job = await prisma.job.findUnique({ where: { id } });
  return NextResponse.json({ ok: !!job, job });
}

GitHub install/webhook/PR ‚Äî apps/web/app/api/github/*

install/route.ts ‚Äì convenience landing (your GitHub App install URL redirection):

import { NextRequest, NextResponse } from "next/server";
export async function GET() {
  return NextResponse.redirect("https://github.com/apps/YOUR-GH-APP/installations/new");
}


webhook/route.ts:

import { NextRequest, NextResponse } from "next/server";
import { appOctokit } from "@/lib/github";

export async function POST(req: NextRequest) {
  const app = appOctokit();
  const sig = req.headers.get("x-hub-signature-256") || "";
  const id = req.headers.get("x-github-delivery") || "";
  const evt = req.headers.get("x-github-event") || "unknown";
  const payload = await req.text();

  try {
    await app.webhooks.verifyAndReceive({
      id,
      name: evt as any,
      payload,
      signature: sig
    });
    return NextResponse.json({ ok: true });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e.message }, { status: 400 });
  }
}


pr/route.ts (create PR from code/artifact text):

import { NextRequest, NextResponse } from "next/server";
import { installationClient } from "@/lib/github";

export async function POST(req: NextRequest) {
  const { installationId, owner, repo, branch = "ai/update", base = "main", path, content, message } = await req.json();
  const octo = await installationClient(Number(installationId));
  const { data: ref } = await octo.rest.git.getRef({ owner, repo, ref: "heads/" + base });
  const baseSha = ref.object.sha;

  const { data: branchRef } = await octo.rest.git.createRef({
    owner, repo, ref: "refs/heads/" + branch, sha: baseSha
  });

  // create/update file
  const buff = Buffer.from(content, "utf8").toString("base64");
  await octo.rest.repos.createOrUpdateFileContents({
    owner, repo, path, message: message || "AI update", content: buff, branch
  });

  const pr = await octo.rest.pulls.create({ owner, repo, title: message || "AI PR", head: branch, base });
  return NextResponse.json({ ok: true, url: pr.data.html_url });
}

üßë‚Äçüîß UI components (apps/web/components/*)
ChatWindow.tsx
"use client";
import { useState } from "react";

export default function ChatWindow({ projectId }: { projectId?: string }) {
  const [messages, setMessages] = useState<{ role: "user"|"assistant"; content: string }[]>([]);
  const [input, setInput] = useState("");
  async function send() {
    const token = (globalThis as any).supabase?.auth?.getSession?.() ? "" : ""; // inject if you wire client auth
    const res = await fetch("/app/api/chat", { method: "POST" } as any); // placeholder to satisfy Next bundler
  }
  async function onSend() {
    const userMsg = { role: "user" as const, content: input };
    setMessages(m => [...m, userMsg]);
    setInput("");
    const resp = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ messages: [{ role: "user", content: userMsg.content }], projectId })
    });
    const data = await resp.json();
    setMessages(m => [...m, { role: "assistant", content: data.message }]);
  }
  return (
    <div className="rounded-xl border border-zinc-800 p-4 space-y-3">
      <div className="text-sm text-zinc-400">Project Chat</div>
      <div className="min-h-[220px] max-h-[320px] overflow-y-auto bg-zinc-900/50 p-3 rounded">
        {messages.map((m, i) => (
          <div key={i} className={m.role === "user" ? "text-blue-300" : "text-emerald-300"}>{m.role}: {m.content}</div>
        ))}
      </div>
      <div className="flex gap-2">
        <input className="flex-1 bg-zinc-900 rounded px-3 py-2 border border-zinc-800"
               value={input} onChange={e => setInput(e.target.value)} placeholder="Type a message..." />
        <button onClick={onSend} className="px-3 py-2 rounded bg-blue-600">Send</button>
      </div>
    </div>
  );
}

ProjectSidebar.tsx
import Link from "next/link";

export default function ProjectSidebar({ activeProjectId }: { activeProjectId?: string }) {
  // For brevity, static list‚Äîwire to DB in your first pass
  const projects = [{ id: "demo", name: "Demo Project" }];
  return (
    <div className="rounded-xl border border-zinc-800 p-4">
      <div className="font-semibold mb-2">Projects</div>
      <div className="space-y-2">
        {projects.map(p => (
          <Link key={p.id} href={`/project/${p.id}`} className={`block px-3 py-2 rounded border border-zinc-800 ${activeProjectId === p.id ? "bg-zinc-900" : ""}`}>
            {p.name}
          </Link>
        ))}
      </div>
      <div className="mt-4 text-sm text-zinc-400">Create, ingest docs, and chat with your data.</div>
    </div>
  );
}

ArtifactViewer.tsx
export default function ArtifactViewer({ projectId }: { projectId: string }) {
  // Render latest artifacts (in real build, fetch from /api)
  return (
    <div className="rounded-xl border border-zinc-800 p-4">
      <div className="font-semibold mb-2">Artifacts</div>
      <div className="text-sm text-zinc-400">Generated assets (UI code, diagrams, files) will appear here.</div>
    </div>
  );
}

VoiceWidget.tsx
"use client";
import { useState, useRef } from "react";

export default function VoiceWidget() {
  const [text, setText] = useState("Hello from the AI portal.");
  const audioRef = useRef<HTMLAudioElement>(null);

  async function speak() {
    const res = await fetch("/api/voice/tts", {
      method: "POST", headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text })
    });
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    if (audioRef.current) { audioRef.current.src = url; audioRef.current.play(); }
  }

  return (
    <div className="rounded-xl border border-zinc-800 p-4 space-y-2">
      <div className="font-semibold">Voice</div>
      <textarea className="w-full bg-zinc-900 border border-zinc-800 rounded p-2" rows={3} value={text} onChange={e => setText(e.target.value)} />
      <div className="flex gap-2">
        <button onClick={speak} className="px-3 py-2 rounded bg-blue-600">Speak</button>
        <audio ref={audioRef} controls className="w-full" />
      </div>
    </div>
  );
}

Topbar.tsx
export default function Topbar({ title }: { title: string }) {
  return (
    <div className="rounded-xl border border-zinc-800 p-4 flex items-center justify-between">
      <div className="font-semibold">{title}</div>
      <div className="text-sm text-zinc-400">Signed in via Supabase</div>
    </div>
  );
}

üó£ apps/web/app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

html, body { height: 100%; }

üßµ Worker
apps/worker/package.json
{
  "name": "@ai/worker",
  "private": true,
  "type": "module",
  "scripts": {
    "start": "tsx src/index.ts"
  },
  "dependencies": {
    "@ai/shared": "workspace:*",
    "openai": "^4.55.4",
    "pg-boss": "^9.0.3",
    "zod": "^3.23.8",
    "tsx": "^4.16.0",
    "pdf-parse": "^1.1.1",
    "@chromadb/client": "^1.9.2"
  }
}

apps/worker/src/index.ts
import PgBoss from "pg-boss";
import { deepResearch } from "./jobs/deepResearch";
import { githubPR } from "./jobs/githubPR";
import { ingestDoc } from "./jobs/ingestDoc";
import { refreshArtifacts } from "./jobs/refreshArtifacts";

async function main() {
  const boss = new PgBoss({
    connectionString: process.env.DATABASE_URL!,
    schema: process.env.JOB_QUEUE_SCHEMA || "boss"
  });
  await boss.start();

  await boss.work("deep_research", deepResearch);
  await boss.work("github_pr", githubPR);
  await boss.work("ingest_doc", ingestDoc);
  await boss.work("refresh_artifacts", refreshArtifacts);

  console.log("Worker up");
}
main().catch(err => { console.error(err); process.exit(1); });

apps/worker/src/jobs/deepResearch.ts
import OpenAI from "openai";
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function deepResearch(job: any) {
  const { query } = job.data;
  const prompt = [
    { role: "system", content: "You are an analyst. Search, summarize, and structure findings." },
    { role: "user", content: `Research task:\n${query}\nDeliver: key points, citations, risks, next steps.` }
  ];
  const res = await openai.chat.completions.create({ model: "gpt-4o-mini", messages: prompt, temperature: 0.2, max_tokens: 1400 });
  return { report: res.choices[0]?.message?.content ?? "" };
}

apps/worker/src/jobs/githubPR.ts
import { Octokit } from "octokit";
import { App } from "@octokit/app";

export async function githubPR(job: any) {
  const { owner, repo, path, content, title = "AI PR", base = "main", branch = "ai/update", installationId } = job.data;
  const app = new App({
    appId: process.env.GITHUB_APP_ID!,
    privateKey: process.env.GITHUB_APP_PRIVATE_KEY!.replace(/\\n/g, "\n")
  });
  const token = await app.getInstallationAccessToken({ installationId });
  const octo = new Octokit({ auth: token });

  const ref = await octo.rest.git.getRef({ owner, repo, ref: "heads/" + base });
  await octo.rest.git.createRef({ owner, repo, ref: "refs/heads/" + branch, sha: ref.data.object.sha });
  await octo.rest.repos.createOrUpdateFileContents({
    owner, repo, path, message: title, content: Buffer.from(content, "utf8").toString("base64"), branch
  });
  const pr = await octo.rest.pulls.create({ owner, repo, title, head: branch, base });
  return { url: pr.data.html_url };
}

apps/worker/src/jobs/ingestDoc.ts
import { ChromaClient } from "@chromadb/client";
import OpenAI from "openai";
import pdf from "pdf-parse";

export async function ingestDoc(job: any) {
  const { bufBase64, filename, collection = process.env.CHROMA_COLLECTION } = job.data;
  const client = new ChromaClient({ path: process.env.CHROMA_URL! });
  const col = await client.getOrCreateCollection({ name: collection! });
  const buf = Buffer.from(bufBase64, "base64");

  let text = buf.toString("utf8");
  if (filename.endsWith(".pdf")) text = (await pdf(buf)).text;

  const chunks: string[] = [];
  for (let i = 0; i < text.length; i += 1500) chunks.push(text.slice(i, i + 1500));

  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });
  const embeds = await openai.embeddings.create({ model: "text-embedding-3-large", input: chunks });

  await col.upsert({
    ids: chunks.map((_, i) => `${Date.now()}-${i}`),
    documents: chunks,
    embeddings: embeds.data.map(e => e.embedding)
  });

  return { chunks: chunks.length };
}

apps/worker/src/jobs/refreshArtifacts.ts
export async function refreshArtifacts(job: any) {
  // Placeholder: scan project state and regenerate artifacts if stale
  return { ok: true };
}

üì¶ packages/shared/src/types.ts
export type ChatMessage = { role: "system"|"user"|"assistant"; content: string };

üì¶ packages/shared/src/sdk.ts
export class PortalSDK {
  constructor(private base = "") {}
  async chat(messages: any[], token?: string, projectId?: string) {
    const r = await fetch(this.base + "/api/chat", {
      method: "POST", headers: { "Content-Type": "application/json", ...(token ? { Authorization: "Bearer " + token } : {}) },
      body: JSON.stringify({ messages, projectId })
    });
    return r.json();
  }
}

‚ñ∂Ô∏è Setup & run

Install

pnpm i
pnpm prisma generate
pnpm prisma migrate dev


Configure

Copy .env.example ‚Üí .env and fill keys (OpenAI, Supabase, Neon, Replicate, GitHub App).

Start a Chroma server locally (chroma run --path ./chroma-data) or use hosted Chroma and set CHROMA_URL.

Dev

pnpm --filter @ai/web dev   # http://localhost:3000
pnpm --filter @ai/worker start  # starts job workers


On Replit: create two repls or one with two processes (web + worker). Add env vars in Secrets.

Notes & extensions

Auth wiring in UI: For brevity I didn‚Äôt include the Supabase client wiring in components; add @supabase/supabase-js and initialize it (client & server), then attach the Bearer token in requests (see lib/auth.ts verifier).

pgvector alternative: If you want embeddings in Neon instead of Chroma, enable pgvector on Neon and store vectors via Prisma raw SQL; I can drop in that variant if you prefer.

Video models: Swap the Replicate version to your preferred model (Luma, Pika). The route returns job id; poll Replicate /predictions/{id} to get the final video URL.

Deep Research: The worker job is a minimal skeleton‚Äîexpand it to do multi-hop browse ‚Üí summarize ‚Üí cite, then save an Artifact (saveArtifact) with a report.

Artifacts playground: You can render kind: 'react'|'html'|'mermaid' dynamically in ArtifactViewer to match an ‚ÄúArtifacts‚Äù feature.