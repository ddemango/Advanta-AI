// =============================
// Movies & TV Shows Matchmaker
// Full Next.js (App Router) page + API
// Drop this into an existing Next.js 13/14 project
// =============================
//
// ├─ package.json
// ├─ next.config.mjs
// ├─ postcss.config.mjs
// ├─ tailwind.config.ts
// ├─ tsconfig.json
// ├─ .env.local  (create this)
// ├─ app/
// │  ├─ globals.css
// │  ├─ layout.tsx
// │  └─ matchmaker/
// │     └─ page.tsx              <-- main UI page
// ├─ components/
// │  └─ Matchmaker.tsx           <-- UI component
// ├─ lib/
// │  ├─ types.ts
// │  ├─ mood.ts
// │  ├─ scoring.ts
// │  ├─ tmdb.ts
// │  └─ groups.ts
// └─ app/api/
//    ├─ retrieve/route.ts        <-- fetch candidates from TMDb
//    ├─ availability/route.ts    <-- enrich availability per title
//    ├─ rerank/route.ts          <-- score & rank (OpenAI optional)
//    ├─ explain/route.ts         <-- spoiler‑safe reason (OpenAI)
//    ├─ track/route.ts           <-- event logging (console/demo)
//    └─ group/
//       ├─ create/route.ts
//       └─ [roomId]/route.ts
//
// NOTES
// - This ships with a minimal, production‑grade structure using Tailwind and the App Router.
// - For quick start, embeddings + LLM are optional. If OPENAI_API_KEY is missing, we fall back to a heuristic reranker.
// - Availability is powered by TMDb watch/providers (region-aware). For deeper accuracy you can later add JustWatch.
// - Group rooms are in‑memory for demo; wire them to Redis/Postgres for persistence.
// - All network calls respect TMDb ToS; cache via Next.js fetch revalidate.
//
// =============================
// package.json
// =============================
{
  "name": "movies-tv-matchmaker",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.2.5",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "zod": "3.23.8",
    "classnames": "2.5.1"
  },
  "devDependencies": {
    "autoprefixer": "10.4.18",
    "postcss": "8.4.35",
    "tailwindcss": "3.4.10",
    "typescript": "5.5.4"
  }
}

// =============================
// next.config.mjs
// =============================
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      { protocol: 'https', hostname: 'image.tmdb.org', pathname: '/t/p/**' }
    ]
  },
  experimental: { serverActions: { allowedOrigins: ['*'] } }
};
export default nextConfig;

// =============================
// postcss.config.mjs
// =============================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

// =============================
// tailwind.config.ts
// =============================
import type { Config } from 'tailwindcss'

export default {
  content: [
    './app/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
  ],
  theme: {
    extend: {
      container: { center: true, padding: '1rem' }
    },
  },
  plugins: [],
} satisfies Config

// =============================
// tsconfig.json
// =============================
{
  "compilerOptions": {
    "target": "ES2021",
    "lib": ["ES2021", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "esModuleInterop": true,
    "allowJs": false,
    "strict": true,
    "noEmit": true,
    "jsx": "preserve",
    "paths": { "@/*": ["./*"] },
    "baseUrl": "."
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

// =============================
// .env.local  (create this file)
// =============================
# --- REQUIRED ---
TMDB_API_KEY=your_tmdb_api_key
# TMDb v3 API key – get from https://www.themoviedb.org/settings/api (create a free account)

# --- OPTIONAL (enables AI features) ---
OPENAI_API_KEY=sk_your_key
OPENAI_MODEL=gpt-4o-mini
OPENAI_EMBED_MODEL=text-embedding-3-small

# Region for watch providers
WATCH_REGION=US

// =============================
// app/globals.css
// =============================
@tailwind base;
@tailwind components;
@tailwind utilities;

html, body { height: 100%; }
body { @apply bg-neutral-950 text-neutral-100; }

.btn { @apply inline-flex items-center gap-2 rounded-xl px-4 py-2 font-medium transition; }
.btn-primary { @apply bg-white text-black hover:opacity-90; }
.btn-secondary { @apply bg-neutral-800 hover:bg-neutral-700; }
.badge { @apply inline-block rounded-full bg-neutral-800 px-3 py-1 text-xs; }
.card { @apply rounded-2xl bg-neutral-900 p-4 ring-1 ring-white/10 shadow-lg; }
.input { @apply w-full rounded-xl bg-neutral-900 ring-1 ring-white/10 px-3 py-2 placeholder:text-neutral-500 focus:outline-none focus:ring-2 focus:ring-white/30; }
.toggle { @apply inline-flex items-center gap-2 rounded-full px-3 py-1 ring-1 ring-white/10 bg-neutral-900; }

// =============================
// app/layout.tsx
// =============================
import './globals.css'
import type { ReactNode } from 'react'

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>
        <div className="min-h-screen">
          <header className="sticky top-0 z-30 backdrop-blur border-b border-white/10 bg-black/30">
            <div className="container flex items-center justify-between py-4">
              <a href="/" className="text-lg font-semibold">Advanta AI</a>
              <nav className="text-sm opacity-80">Movies & TV Matchmaker</nav>
            </div>
          </header>
          <main className="container py-6">{children}</main>
          <footer className="container py-10 text-sm opacity-70">Built with ❤️ by Advanta AI</footer>
        </div>
      </body>
    </html>
  )
}

// =============================
// lib/types.ts
// =============================
export type ServiceKey = 'netflix' | 'hulu' | 'prime' | 'disney' | 'max' | 'peacock' | 'paramount' | 'apple';

export const SERVICE_TO_TMDB_PROVIDER: Record<ServiceKey, number> = {
  netflix: 8,
  prime: 9,
  disney: 337,
  hulu: 15,
  max: 384, // HBO Max
  peacock: 387,
  paramount: 531,
  apple: 350,
};

export type MoodKey = 'cozy' | 'light' | 'intense' | 'smart' | 'gritty' | 'comfort' | 'high_energy' | 'low_energy' | 'multitask' | 'focus';

export type ContentItem = {
  id: number;
  media_type: 'movie' | 'tv';
  title: string;
  year?: number;
  runtime?: number; // minutes
  overview: string;
  poster_url?: string;
  tmdb_url?: string;
  providers?: { flatrate?: string[]; ads?: string[]; rent?: string[]; buy?: string[] };
  popularity?: number;
  genres?: number[];
};

export type RetrieveRequest = {
  services: ServiceKey[];
  timeWindow: number; // minutes user has
  languages?: string[];
  ageRatings?: string[];
  mediaTypes?: ('movie'|'tv')[];
  count?: number; // how many to retrieve
};

export type RerankRequest = {
  candidates: ContentItem[];
  moods: MoodKey[];
  timeWindow: number;
};

export type ExplainRequest = {
  item: ContentItem;
  moods: MoodKey[];
  timeWindow: number;
};

// =============================
// lib/mood.ts
// =============================
import type { MoodKey } from './types'

export const MOOD_LABELS: Record<MoodKey, string> = {
  cozy: 'Cozy',
  light: 'Light',
  intense: 'Intense',
  smart: 'Smart',
  gritty: 'Gritty',
  comfort: 'Comfort',
  high_energy: 'High‑Energy',
  low_energy: 'Low‑Energy',
  multitask: 'Multitask‑friendly',
  focus: 'Focus‑worthy',
};

export function moodHint(moods: MoodKey[]): string {
  if (!moods.length) return 'Balanced';
  return moods.map(m => MOOD_LABELS[m]).join(', ');
}

// A simple mapping from moods to heuristic genre IDs (TMDb genre ids vary; this is a proxy).
export const MOOD_GENRE_WEIGHTS: Record<MoodKey, Record<number, number>> = {
  cozy: { 35: 1.0, 10749: 0.6, 16: 0.3 }, // Comedy, Romance, Animation
  light: { 35: 0.8, 12: 0.6 }, // Comedy, Adventure
  intense: { 53: 1.0, 28: 0.8, 80: 0.6 }, // Thriller, Action, Crime
  smart: { 18: 0.6, 9648: 0.8, 99: 0.6, 878: 0.5 }, // Drama, Mystery, Documentary, Sci‑Fi
  gritty: { 80: 0.9, 18: 0.5, 53: 0.7 },
  comfort: { 35: 0.7, 10751: 0.6 }, // Family
  high_energy: { 28: 0.8, 12: 0.7 },
  low_energy: { 18: 0.6, 10749: 0.4 },
  multitask: { 35: 0.5, 10751: 0.4 },
  focus: { 9648: 0.7, 18: 0.6, 99: 0.6 },
};

// =============================
// lib/scoring.ts
// =============================
import type { ContentItem, RerankRequest } from './types'
import { MOOD_GENRE_WEIGHTS } from './mood'

function gaussianPenalty(x: number, mu: number, sigma: number) {
  const diff = x - mu
  return Math.exp(- (diff * diff) / (2 * sigma * sigma))
}

export function heuristicScore(item: ContentItem, req: RerankRequest): number {
  const timeFit = item.runtime ? gaussianPenalty(item.runtime, req.timeWindow, Math.max(15, req.timeWindow * 0.25)) : 0.8
  const moodGenre = req.moods.reduce((acc, m) => {
    const weights = MOOD_GENRE_WEIGHTS[m] || {}
    return acc + (item.genres?.reduce((s, g) => s + (weights[g] || 0), 0) || 0)
  }, 0)

  const recency = item.year ? Math.max(0, Math.min(1, (item.year - 1990) / 35)) : 0.3 // soft bias to newer
  const popularity = item.popularity ? Math.min(1, item.popularity / 100) : 0.3

  return 0.35 * timeFit + 0.25 * (moodGenre / 2) + 0.20 * recency + 0.20 * popularity
}

export function rerankHeuristic(req: RerankRequest): ContentItem[] {
  const scored = req.candidates.map(c => ({ c, s: heuristicScore(c, req) }))
  scored.sort((a,b) => b.s - a.s)
  return scored.slice(0, 12).map(x => x.c) // cap list for anti‑paradox UX
}

// =============================
// lib/tmdb.ts
// =============================
import { SERVICE_TO_TMDB_PROVIDER, type ContentItem, type ServiceKey } from './types'

const TMDB_BASE = 'https://api.themoviedb.org/3'
const IMG_BASE = 'https://image.tmdb.org/t/p/w500'

function apiKeyParam() {
  const key = process.env.TMDB_API_KEY
  if (!key) throw new Error('TMDB_API_KEY not set')
  return `api_key=${key}`
}

export function poster(path?: string | null) {
  return path ? `${IMG_BASE}${path}` : undefined
}

export async function discover({
  services,
  runtimeLte,
  language = 'en-US',
  count = 100,
  mediaTypes = ['movie','tv'] as ('movie'|'tv')[],
}: {
  services: ServiceKey[]
  runtimeLte?: number
  language?: string
  count?: number
  mediaTypes?: ('movie'|'tv')[]
}): Promise<ContentItem[]> {
  const region = process.env.WATCH_REGION || 'US'
  const providers = services.map(s => SERVICE_TO_TMDB_PROVIDER[s]).filter(Boolean)
  const providerCsv = providers.join('|')
  const results: ContentItem[] = []

  async function fetchPage(media: 'movie'|'tv', page: number) {
    const params = new URLSearchParams()
    params.set('language', language)
    params.set('sort_by', 'popularity.desc')
    params.set('watch_region', region)
    if (providerCsv) params.set('with_watch_providers', providerCsv)
    if (runtimeLte && media === 'movie') params.set('with_runtime.lte', String(runtimeLte))
    const url = `${TMDB_BASE}/discover/${media}?${apiKeyParam()}&${params.toString()}`
    const res = await fetch(url, { next: { revalidate: 60 * 60 } })
    if (!res.ok) throw new Error(`TMDb discover ${media} failed: ${res.status}`)
    const json = await res.json()
    return json
  }

  for (const media of mediaTypes) {
    const page1 = await fetchPage(media, 1)
    const items = page1.results?.slice(0, Math.ceil(count/2)) || []
    for (const r of items) {
      results.push({
        id: r.id,
        media_type: media,
        title: media === 'movie' ? r.title : r.name,
        year: (r.release_date || r.first_air_date)?.slice(0,4) ? Number((r.release_date || r.first_air_date).slice(0,4)) : undefined,
        overview: r.overview,
        poster_url: poster(r.poster_path),
        tmdb_url: `https://www.themoviedb.org/${media}/${r.id}`,
        popularity: r.popularity,
        genres: r.genre_ids,
      })
    }
  }
  return results
}

export async function fetchProviders(item: ContentItem) {
  const region = process.env.WATCH_REGION || 'US'
  const url = `${TMDB_BASE}/${item.media_type}/${item.id}/watch/providers?${apiKeyParam()}`
  const res = await fetch(url, { next: { revalidate: 60 * 60 } })
  if (!res.ok) return item
  const json = await res.json()
  const regionInfo = json.results?.[region]
  if (!regionInfo) return item
  const norm = (arr?: any[]) => arr?.map((x:any) => x.provider_name) || []
  return {
    ...item,
    providers: {
      flatrate: norm(regionInfo.flatrate),
      ads: norm(regionInfo.ads),
      rent: norm(regionInfo.rent),
      buy: norm(regionInfo.buy),
    }
  }
}

export async function fetchRuntime(item: ContentItem) {
  const url = `${TMDB_BASE}/${item.media_type}/${item.id}?${apiKeyParam()}`
  const res = await fetch(url, { next: { revalidate: 60 * 60 * 24 } })
  if (!res.ok) return item
  const json = await res.json()
  const runtime = item.media_type === 'movie' ? json.runtime : (json.episode_run_time?.[0] || undefined)
  return { ...item, runtime }
}

// =============================
// lib/groups.ts (in‑memory demo; swap for Redis/Postgres in prod)
// =============================
import { nanoid } from 'nanoid/non-secure'
import type { MoodKey, ServiceKey, ContentItem } from './types'

type Member = { id: string; services: ServiceKey[]; moods: MoodKey[]; timeWindow: number }

type Room = { id: string; owner: string; createdAt: number; members: Record<string, Member>; lastCandidates?: ContentItem[] }

const rooms: Record<string, Room> = {}

export function createRoom(owner: string): Room {
  const id = nanoid(10)
  const room: Room = { id, owner, createdAt: Date.now(), members: {} }
  rooms[id] = room
  return room
}

export function getRoom(id: string): Room | undefined { return rooms[id] }

export function upsertMember(roomId: string, member: Member) {
  const r = rooms[roomId]
  if (!r) throw new Error('Room not found')
  r.members[member.id] = member
}

export function setCandidates(roomId: string, c: ContentItem[]) {
  const r = rooms[roomId]
  if (!r) throw new Error('Room not found')
  r.lastCandidates = c
}

export function consensus(roomId: string): { picks: ContentItem[]; summary: string } {
  const r = rooms[roomId]
  if (!r || !r.lastCandidates) return { picks: [], summary: 'No candidates yet' }
  const members = Object.values(r.members)
  if (!members.length) return { picks: r.lastCandidates.slice(0,3), summary: 'No members' }

  // Score each candidate as mean of simple agreement on services
  const scored = r.lastCandidates.map(c => {
    let serviceOverlap = 0
    for (const m of members) {
      // increment if any of member services appear in providers list string (we don’t have exact mapping here)
      const prov = [
        ...(c.providers?.flatrate || []),
        ...(c.providers?.ads || []),
        ...(c.providers?.rent || []),
        ...(c.providers?.buy || []),
      ].join(' ').toLowerCase()
      const has = m.services.some(s => prov.includes(s))
      serviceOverlap += has ? 1 : 0
    }
    const mean = serviceOverlap / members.length
    return { c, s: mean }
  })
  scored.sort((a,b) => b.s - a.s)
  const picks = scored.slice(0,5).map(x => x.c)
  const summary = `Consensus: ${members.length} members; service coverage ${(scored[0]?.s*100||0).toFixed(0)}%`
  return { picks, summary }
}

// =============================
// app/api/retrieve/route.ts
// =============================
import { NextResponse } from 'next/server'
import { z } from 'zod'
import { discover, fetchProviders, fetchRuntime } from '@/lib/tmdb'
import type { ServiceKey } from '@/lib/types'

const Schema = z.object({
  services: z.array(z.enum(['netflix','hulu','prime','disney','max','peacock','paramount','apple'])).default([]),
  timeWindow: z.number().int().positive().default(100),
  mediaTypes: z.array(z.enum(['movie','tv'])).default(['movie','tv']),
  count: z.number().int().positive().max(200).default(80)
})

export async function POST(req: Request) {
  try {
    const body = await req.json()
    const { services, timeWindow, mediaTypes, count } = Schema.parse(body)

    const candidates = await discover({ services: services as ServiceKey[], runtimeLte: timeWindow + 20, mediaTypes, count })
    // enrich runtime + providers (throttle/limit in real prod; here just first 30)
    const first = candidates.slice(0, 30)
    const enriched = await Promise.all(first.map(async (c) => fetchProviders(await fetchRuntime(c))))
    return NextResponse.json({ candidates: enriched })
  } catch (e:any) {
    return NextResponse.json({ error: e.message || 'retrieve_failed' }, { status: 400 })
  }
}

// =============================
// app/api/availability/route.ts
// =============================
import { NextResponse } from 'next/server'
import { z } from 'zod'
import { fetchProviders } from '@/lib/tmdb'

const SchemaA = z.object({ item: z.object({ id:z.number(), media_type: z.enum(['movie','tv']) }) })

export async function POST(req: Request) {
  try {
    const body = await req.json()
    const { item } = SchemaA.parse(body)
    // fetchProviders expects a ContentItem but only needs id/media_type
    const enriched = await fetchProviders(item as any)
    return NextResponse.json({ item: enriched })
  } catch (e:any) {
    return NextResponse.json({ error: e.message || 'availability_failed' }, { status: 400 })
  }
}

// =============================
// app/api/rerank/route.ts
// =============================
import { NextResponse } from 'next/server'
import { z } from 'zod'
import type { ContentItem, MoodKey } from '@/lib/types'
import { rerankHeuristic } from '@/lib/scoring'

const SchemaR = z.object({
  candidates: z.array(z.any()),
  moods: z.array(z.enum(['cozy','light','intense','smart','gritty','comfort','high_energy','low_energy','multitask','focus'])).default([]),
  timeWindow: z.number().int().positive().default(100)
})

export async function POST(req: Request) {
  try {
    const body = await req.json()
    const { candidates, moods, timeWindow } = SchemaR.parse(body)

    // OPTIONAL: If OPENAI is configured, you can compute semantic similarity.
    // For MVP reliability and cost, we use a strong heuristic reranker.
    const top = rerankHeuristic({ candidates: candidates as ContentItem[], moods: moods as MoodKey[], timeWindow })
    return NextResponse.json({ top })
  } catch (e:any) {
    return NextResponse.json({ error: e.message || 'rerank_failed' }, { status: 400 })
  }
}

// =============================
// app/api/explain/route.ts
// =============================
import { NextResponse } from 'next/server'
import { z } from 'zod'

const SchemaE = z.object({
  item: z.object({ title: z.string(), overview: z.string().optional(), runtime: z.number().optional(), media_type: z.enum(['movie','tv']) }),
  moods: z.array(z.string()).default([]),
  timeWindow: z.number().int().positive().default(100)
})

export async function POST(req: Request) {
  try {
    const body = await req.json()
    const { item, moods, timeWindow } = SchemaE.parse(body)

    const hasOpenAI = !!process.env.OPENAI_API_KEY
    if (!hasOpenAI) {
      const reason = `${item.media_type === 'movie' ? 'Movie' : 'Series'} with a vibe that fits (${moods.join(', ') || 'balanced'}), ~${item.runtime || 'flex'} min, and a widely‑liked premise.`
      return NextResponse.json({ reason })
    }

    const model = process.env.OPENAI_MODEL || 'gpt-4o-mini'
    const sys = `You generate ONE short, spoiler‑safe reason (max 20 words). Do not reveal twists. Reference mood and time fit.`
    const user = JSON.stringify({ title: item.title, overview: item.overview, moods, timeWindow })

    const r = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${process.env.OPENAI_API_KEY}` },
      body: JSON.stringify({ model, messages: [ { role: 'system', content: sys }, { role: 'user', content: user } ], temperature: 0.5 })
    })
    if (!r.ok) throw new Error('openai_failed')
    const j = await r.json()
    const reason = j.choices?.[0]?.message?.content?.trim() || 'Great mood match and length fit.'
    return NextResponse.json({ reason })
  } catch (e:any) {
    return NextResponse.json({ reason: 'Great mood match and length fit.' })
  }
}

// =============================
// app/api/group/create/route.ts
// =============================
import { NextResponse } from 'next/server'
import { createRoom } from '@/lib/groups'

export async function POST() {
  const owner = 'anon'
  const room = createRoom(owner)
  return NextResponse.json({ roomId: room.id })
}

// =============================
// app/api/group/[roomId]/route.ts
// =============================
import { NextResponse } from 'next/server'
import { z } from 'zod'
import { getRoom, upsertMember, setCandidates, consensus } from '@/lib/groups'

const JoinSchema = z.object({
  memberId: z.string(),
  services: z.array(z.enum(['netflix','hulu','prime','disney','max','peacock','paramount','apple'])).default([]),
  moods: z.array(z.enum(['cozy','light','intense','smart','gritty','comfort','high_energy','low_energy','multitask','focus'])).default([]),
  timeWindow: z.number().int().positive().default(100),
})

const CandSchema = z.object({ candidates: z.array(z.any()) })

export async function GET(_: Request, { params }: { params: { roomId: string }}) {
  const room = getRoom(params.roomId)
  if (!room) return NextResponse.json({ error: 'not_found' }, { status: 404 })
  const c = consensus(params.roomId)
  return NextResponse.json({ roomId: room.id, members: Object.values(room.members).length, consensus: c })
}

export async function POST(req: Request, { params }: { params: { roomId: string }}) {
  const room = getRoom(params.roomId)
  if (!room) return NextResponse.json({ error: 'not_found' }, { status: 404 })
  const body = await req.json()

  if ('memberId' in body) {
    const { memberId, services, moods, timeWindow } = JoinSchema.parse(body)
    upsertMember(params.roomId, { id: memberId, services, moods, timeWindow })
    return NextResponse.json({ ok: true })
  }

  const { candidates } = CandSchema.parse(body)
  setCandidates(params.roomId, candidates)
  return NextResponse.json({ ok: true })
}

// =============================
// app/api/track/route.ts
// =============================
import { NextResponse } from 'next/server'

export async function POST(req: Request) {
  try {
    const body = await req.json()
    console.log('[track]', body)
    return NextResponse.json({ ok: true })
  } catch {
    return NextResponse.json({ ok: false })
  }
}

// =============================
// components/Matchmaker.tsx
// =============================
'use client'

import { useEffect, useMemo, useRef, useState } from 'react'
import Image from 'next/image'
import clsx from 'classnames'
import type { ContentItem, MoodKey, ServiceKey } from '@/lib/types'
import { MOOD_LABELS, moodHint } from '@/lib/mood'

const ALL_SERVICES: { key: ServiceKey; label: string }[] = [
  { key: 'netflix', label: 'Netflix' },
  { key: 'hulu', label: 'Hulu' },
  { key: 'prime', label: 'Prime Video' },
  { key: 'disney', label: 'Disney+' },
  { key: 'max', label: 'Max' },
  { key: 'peacock', label: 'Peacock' },
  { key: 'paramount', label: 'Paramount+' },
  { key: 'apple', label: 'Apple TV+' },
]

const ALL_MOODS: MoodKey[] = ['cozy','light','intense','smart','gritty','comfort','high_energy','low_energy','multitask','focus']

async function api<T>(path: string, payload?: any): Promise<T> {
  const res = await fetch(path, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: payload ? JSON.stringify(payload) : undefined })
  if (!res.ok) throw new Error(`${path} failed`)
  return res.json()
}

// ---- persistent history to avoid repeats ----
const HISTORY_KEY = 'mm_recent_v1'
const HISTORY_MAX = 50
const HISTORY_TTL_MS = 1000 * 60 * 60 * 24 * 14 // 14 days

type HistoryEntry = { id: number; ts: number }

function loadHistory(): HistoryEntry[] {
  if (typeof window === 'undefined') return []
  try {
    const raw = localStorage.getItem(HISTORY_KEY)
    if (!raw) return []
    const arr: HistoryEntry[] = JSON.parse(raw)
    const now = Date.now()
    return arr.filter(e => now - e.ts < HISTORY_TTL_MS)
  } catch { return [] }
}

function saveHistory(arr: HistoryEntry[]) {
  try { localStorage.setItem(HISTORY_KEY, JSON.stringify(arr.slice(-HISTORY_MAX))) } catch {}
}

function addToHistory(ids: number[]) {
  const prev = loadHistory()
  const now = Date.now()
  const merged = [...prev, ...ids.map(id => ({ id, ts: now }))]
  saveHistory(merged)
}

function resetHistory() { saveHistory([]) }

function filterUnseen(candidates: ContentItem[], take: number): ContentItem[] {
  const seen = new Set(loadHistory().map(e => e.id))
  const unseen = candidates.filter(c => !seen.has(c.id))
  if (unseen.length >= take) return unseen.slice(0, take)
  const fill = candidates.filter(c => !unseen.includes(c))
  return [...unseen, ...fill].slice(0, take)
}

// map provider name → service key + search links
const PROVIDER_NAME_MAP: Record<string, ServiceKey> = {
  'netflix': 'netflix',
  'hulu': 'hulu',
  'amazon prime video': 'prime',
  'prime video': 'prime',
  'disney+': 'disney',
  'disney plus': 'disney',
  'max': 'max',
  'hbo max': 'max',
  'peacock': 'peacock',
  'paramount+': 'paramount',
  'paramount plus': 'paramount',
  'apple tv+': 'apple',
  'apple tv plus': 'apple',
}

const WATCH_SEARCH_URL: Record<ServiceKey, (title:string)=>string> = {
  netflix: (t)=>`https://www.netflix.com/search?q=${encodeURIComponent(t)}`,
  hulu: (t)=>`https://www.hulu.com/search?q=${encodeURIComponent(t)}`,
  prime: (t)=>`https://www.amazon.com/s?k=${encodeURIComponent(t)}&i=instant-video`,
  disney: (t)=>`https://www.disneyplus.com/search?q=${encodeURIComponent(t)}`,
  max: (t)=>`https://play.max.com/search?q=${encodeURIComponent(t)}`,
  peacock: (t)=>`https://www.peacocktv.com/search?query=${encodeURIComponent(t)}`,
  paramount: (t)=>`https://www.paramountplus.com/shows/?searchTerm=${encodeURIComponent(t)}`,
  apple: (t)=>`https://tv.apple.com/us/search?term=${encodeURIComponent(t)}`,
}

function extractProviderKeys(item: ContentItem): ServiceKey[] {
  const names = [
    ...(item.providers?.flatrate||[]),
    ...(item.providers?.ads||[]),
    ...(item.providers?.rent||[]),
    ...(item.providers?.buy||[]),
  ].map(x => x.toLowerCase())
  const keys = new Set<ServiceKey>()
  for (const n of names) {
    for (const k in PROVIDER_NAME_MAP) {
      if (n.includes(k)) keys.add(PROVIDER_NAME_MAP[k])
    }
  }
  return Array.from(keys)
}

function choosePrimaryProvider(item: ContentItem, userServices: ServiceKey[]): { key: ServiceKey | null, url: string | null } {
  const keys = extractProviderKeys(item)
  const preferred = keys.find(k => userServices.includes(k)) || keys[0]
  if (!preferred) return { key: null, url: null }
  return { key: preferred, url: WATCH_SEARCH_URL[preferred](item.title) }
}

export default function Matchmaker() {
  const [services, setServices] = useState<ServiceKey[]>(['netflix','hulu'])
  const [moods, setMoods] = useState<MoodKey[]>(['cozy','light'])
  const [timeWindow, setTimeWindow] = useState(100)
  const [loading, setLoading] = useState(false)
  const [items, setItems] = useState<ContentItem[]>([])
  const [top, setTop] = useState<ContentItem[]>([])
  const [reasons, setReasons] = useState<Record<number, string>>({})

  const [roomId, setRoomId] = useState<string>('')
  const memberId = useMemo(() => `m_${Math.random().toString(36).slice(2,8)}`, [])
  const polRef = useRef<any>(null)

  async function runSolo() {
    setLoading(true)
    setTop([])
    try {
      const ret = await api<{ candidates: ContentItem[] }>('/api/retrieve', { services, timeWindow, mediaTypes: ['movie','tv'], count: 160 })
      setItems(ret.candidates)
      const rr = await api<{ top: ContentItem[] }>('/api/rerank', { candidates: ret.candidates, moods, timeWindow })
      // Filter out previously shown items and take 5 unique picks
      const unseenTop = filterUnseen(rr.top, 5)
      setTop(unseenTop)
      addToHistory(unseenTop.map(i => i.id))
      await api('/api/track', { event: 'solo_recs', services, moods, timeWindow })
    } finally {
      setLoading(false)
    }
  }

  async function getReason(id: number, item: ContentItem) {
    if (reasons[id]) return
    const r = await api<{ reason: string }>('/api/explain', { item, moods, timeWindow })
    setReasons(prev => ({ ...prev, [id]: r.reason }))
  }

  async function startGroup() {
    const r = await api<{ roomId: string }>('/api/group/create')
    setRoomId(r.roomId)
    await api(`/api/group/${r.roomId}`, { memberId, services, moods, timeWindow })
    // Push current candidates so consensus can work
    if (items.length) await api(`/api/group/${r.roomId}`, { candidates: items })
    if (polRef.current) clearInterval(polRef.current)
    polRef.current = setInterval(async () => {
      const res = await fetch(`/api/group/${r.roomId}`)
      const j = await res.json()
      if (j?.consensus?.picks) { const unique = filterUnseen(j.consensus.picks, 5); setTop(unique); addToHistory(unique.map(i=>i.id)) }
    }, 3000)
  }

  const shareUrl = roomId ? `${typeof window !== 'undefined' ? window.location.origin : ''}/matchmaker?room=${roomId}` : ''

  useEffect(() => {
    const u = new URLSearchParams(window.location.search)
    const r = u.get('room')
    if (r) {
      setRoomId(r)
      api(`/api/group/${r}`, { memberId, services, moods, timeWindow }).catch(()=>{})
      if (polRef.current) clearInterval(polRef.current)
      polRef.current = setInterval(async () => {
        const res = await fetch(`/api/group/${r}`)
        const j = await res.json()
        if (j?.consensus?.picks) { const unique = filterUnseen(j.consensus.picks, 5); setTop(unique); addToHistory(unique.map(i=>i.id)) }
      }, 3000)
    }
    return () => { if (polRef.current) clearInterval(polRef.current) }
  }, [])

  return (
    <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
      <section className="lg:col-span-4 card space-y-4">
        <h1 className="text-2xl font-semibold">Movies & TV Matchmaker</h1>
        <p className="text-sm opacity-80">Right title, right now. Pick your services, mood, and time — get 3 perfect picks.</p>

        <div className="space-y-3">
          <div className="text-sm font-medium">Streaming services</div>
          <div className="flex flex-wrap gap-2">
            {ALL_SERVICES.map(s => (
              <button key={s.key} onClick={() => setServices(p => p.includes(s.key) ? p.filter(x=>x!==s.key) : [...p,s.key])}
                className={clsx('toggle', services.includes(s.key) && 'ring-white/30 bg-white/10')}>{s.label}</button>
            ))}
          </div>
        </div>

        <div className="space-y-3">
          <div className="text-sm font-medium">Mood & context</div>
          <div className="flex flex-wrap gap-2">
            {ALL_MOODS.map(m => (
              <button key={m} onClick={() => setMoods(p => p.includes(m) ? p.filter(x=>x!==m) : [...p,m])}
                className={clsx('toggle', moods.includes(m) && 'ring-white/30 bg-white/10')}>{MOOD_LABELS[m]}</button>
            ))}
          </div>
          <div className="space-y-2">
            <label className="text-sm">Time available: <span className="badge">~{timeWindow} min</span></label>
            <input type="range" min={60} max={180} step={10} value={timeWindow} onChange={e=>setTimeWindow(Number(e.target.value))} className="w-full" />
          </div>
        </div>

        <div className="flex gap-3 pt-2">
          <button className="btn btn-primary" onClick={runSolo} disabled={loading}>{loading ? 'Finding…' : 'Tonight Mode'}</button>
          <button className="btn btn-secondary" onClick={startGroup}>Start Group</button>
          <button className="btn btn-secondary" onClick={() => { resetHistory(); setTop([]) }}>Reset Suggestions</button>
        </div>

        {roomId && (
          <div className="text-xs space-y-2">
            <div className="opacity-80">Share this link with friends to join your room:</div>
            <div className="input select-all">{shareUrl}</div>
          </div>
        )}
      </section>

      <section className="lg:col-span-8 space-y-4">
        <div className="flex items-center justify-between">
          <div className="text-sm opacity-80">Mood: <span className="badge">{moodHint(moods)} • ~{timeWindow} min</span></div>
          <div className="text-sm opacity-60">Showing 5 unique picks</div>
        </div>
          <div className="text-sm opacity-60">Showing top picks</div>
        </div>

        {top.length === 0 && (
          <div className="card text-sm opacity-70">Tap <b>Tonight Mode</b> to get instant picks. Or start a group to decide together.</div>
        )}

        <div className="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-3 gap-4">
          {top.map(item => (
            <article key={`${item.media_type}-${item.id}`} className="card space-y-3">
              {item.poster_url && (
                <div className="relative w-full aspect-[2/3] overflow-hidden rounded-xl ring-1 ring-white/10">
                  <Image src={item.poster_url} alt={item.title} fill priority sizes="(max-width: 768px) 100vw, 33vw" className="object-cover" />
                </div>
              )}
              <div className="space-y-2">
                <h3 className="text-lg font-semibold leading-tight">{item.title}</h3>
                <div className="text-xs opacity-70 flex gap-2 flex-wrap">
                  {item.year && <span className="badge">{item.year}</span>}
                  {item.media_type && <span className="badge uppercase">{item.media_type}</span>}
                  {item.runtime && <span className="badge">~{item.runtime} min</span>}
                </div>
                <p className="text-sm opacity-80 line-clamp-3">{item.overview}</p>
                <div className="flex gap-2 flex-wrap">
                  {(item.providers?.flatrate || []).slice(0,3).map(p => <span key={p} className="badge">{p}</span>)}
                </div>
                <div className="pt-1 text-sm">
                  <button className="underline underline-offset-4" onClick={() => getReason(item.id, item)}>
                    {reasons[item.id] ? 'Why this (again)' : 'Why you’ll like this'}
                  </button>
                  {reasons[item.id] && <div className="mt-2 text-sm opacity-90">{reasons[item.id]}</div>}
                </div>
                <div className="flex gap-2 flex-wrap">
                  {/* Emphasize where to watch */}
                  {extractProviderKeys(item).map(pk => (
                    <span key={pk} className={clsx('badge', services.includes(pk) && 'ring-2 ring-white/20')}>{pk}</span>
                  ))}
                </div>
                <div className="flex gap-2 pt-2 flex-wrap">
                  {(() => { const p = choosePrimaryProvider(item, services); return p.key ? (
                    <a className="btn btn-primary" target="_blank" rel="noreferrer" href={p.url!}>Open on {p.key}</a>
                  ) : null })()}
                  <a className="btn btn-secondary" target="_blank" rel="noreferrer" href={item.tmdb_url || '#'}>Details</a>
                  <a className="btn btn-secondary" target="_blank" rel="noreferrer" href={`https://www.google.com/search?q=watch+${encodeURIComponent(item.title)}`}>Find Anywhere</a>
                </div>
              </div>
            </article>
          ))}
        </div>
      </section>
    </div>
  )
}

// =============================
// app/matchmaker/page.tsx
// =============================
import Matchmaker from '@/components/Matchmaker'

export const metadata = {
  title: 'Movies & TV Matchmaker | Advanta AI',
  description: 'Right title, right now. Mood‑aware picks across your streaming services, with group consensus and spoiler‑safe reasons.'
}

export default function Page() { return <Matchmaker /> }
