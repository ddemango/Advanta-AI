here are the drop-in patches for:

Edge → steps compiler (graph executor)

Results composer that turns a multi-step run into a single Markdown summary artifact

They slot into the worker you already have. No extra schema changes are required.

1) Graph compiler + executor

Compiles a ReactFlow-style graph ({nodes, edges}) into an ordered step list, supports simple templating (later steps can reference earlier outputs), executes each step with your existing Tools registry, and logs to AgentStep.

apps/worker/src/agents/graphCompiler.ts
import { Tools } from "./tools";
import { encode } from "gpt-tokenizer";

export type RFNode = { id: string; data?: any; type?: string };
export type RFEdge = { id?: string; source: string; target: string };
export type RFGraph = { nodes: RFNode[]; edges: RFEdge[] };

export type CompiledStep = {
  nodeId: string;
  tool: keyof typeof Tools;
  input: any;
};

// --- compile: topological order with cycle checks
export function compileGraphToSteps(graph: RFGraph): CompiledStep[] {
  const { nodes, edges } = graph || { nodes: [], edges: [] };
  if (!nodes?.length) return [];

  const idToNode = new Map(nodes.map(n => [n.id, n]));
  const indeg = new Map<string, number>(nodes.map(n => [n.id, 0]));
  const adj = new Map<string, string[]>();

  for (const e of edges || []) {
    if (!idToNode.has(e.source) || !idToNode.has(e.target)) continue;
    indeg.set(e.target, (indeg.get(e.target) ?? 0) + 1);
    adj.set(e.source, [ ...(adj.get(e.source) || []), e.target ]);
  }

  // Kahn's algorithm
  const q: string[] = [];
  for (const [id, d] of indeg.entries()) if (d === 0) q.push(id);

  const order: string[] = [];
  while (q.length) {
     const id = q.shift()!;
     order.push(id);
     for (const nb of (adj.get(id) || [])) {
       indeg.set(nb, (indeg.get(nb) ?? 0) - 1);
       if ((indeg.get(nb) ?? 0) === 0) q.push(nb);
     }
  }

  if (order.length !== nodes.length) {
    // cycle or disconnected w/ back edge
    throw new Error("Graph contains a cycle or invalid edges. Please adjust edges so the graph is a DAG.");
  }

  // map to steps; expect node.data.tool + node.data.input
  const steps: CompiledStep[] = order.map(nodeId => {
    const n = idToNode.get(nodeId)!;
    const label = n?.data?.label?.toString?.().toLowerCase?.() || "";
    const tool = (n?.data?.tool || label || "llm") as keyof typeof Tools;
    const input = n?.data?.input ?? {};
    return { nodeId, tool, input };
  });

  // heuristic: if there is an explicit "plan" node, put it first (already true if indegree==0)
  return steps;
}

// --- tiny template resolver: replaces {{step:<nodeId>.<path.to.value>}}
export function resolveTemplates<T=any>(value: T, bag: Record<string, any>): T {
  if (value == null) return value;
  if (typeof value === "string") {
    return value.replace(/\{\{\s*step:([\w-]+)\.([\w.\[\]0-9]+)\s*\}\}/g, (_, id, path) => {
      const base = bag[id]?.response ?? bag[id];
      const v = pick(base, path);
      return (typeof v === "string") ? v : JSON.stringify(v ?? "");
    }) as unknown as T;
  }
  if (Array.isArray(value)) return value.map(v => resolveTemplates(v, bag)) as unknown as T;
  if (typeof value === "object") {
    const out: any = {};
    for (const [k,v] of Object.entries(value as any)) out[k] = resolveTemplates(v, bag);
    return out;
  }
  return value;
}

function pick(obj: any, path: string) {
  if (!obj) return undefined;
  return path.split(".").reduce((acc, key) => {
    // support simple [index]
    const m = key.match(/^(.+)\[(\d+)\]$/);
    if (m) return acc?.[m[1]]?.[Number(m[2])];
    return acc?.[key];
  }, obj);
}

// --- execute compiled steps with Tools; returns step outputs keyed by nodeId
export async function executeCompiledSteps(ctx: {
  bill: (inTok: number, outTok: number, label: string, meta?: any) => Promise<number>;
  projectId?: string | null;
  userId: string;
  model: string;
  persistStep: (idx: number, nodeId: string, tool: string, status: string, request?: any, response?: any, error?: string) => Promise<void>;
}, compiled: CompiledStep[]) {
  const outputs: Record<string, any> = {};
  let idx = 1;

  for (const st of compiled) {
    const req = resolveTemplates(st.input, outputs);

    await ctx.persistStep(idx, st.nodeId, st.tool, "running", req);
    try {
      // @ts-ignore (tool key is runtime)
      const res = await Tools[st.tool]({ ...ctx, bill: ctx.bill }, req);
      outputs[st.nodeId] = { request: req, response: res };
      await ctx.persistStep(idx, st.nodeId, st.tool, "done", req, res);
    } catch (e: any) {
      await ctx.persistStep(idx, st.nodeId, st.tool, "error", req, undefined, e.message);
      throw e;
    }
    idx++;
  }
  return outputs;
}


Usage notes (templating):

In your DAG editor, put on a node’s Input field strings like:

"prompt": "Summarize findings: {{step:search.response.results[0].snippet}}"


This pulls results[0].snippet from the node with id search and injects it here.

2) Integrate compiler/executor into the runner + compose summary
Patch your existing agentRun job

apps/worker/src/jobs/agentRun.ts (replace the planning block with graph execution if agent.graph exists, then compose the artifact)

import { prisma } from "@ai/shared/prisma";
import { Tools } from "../agents/tools";
import { estimateCredits } from "@ai/shared/pricing";
import { chargeCredits } from "@ai/shared/credits";
import { encode } from "gpt-tokenizer";
import { compileGraphToSteps, executeCompiledSteps } from "../agents/graphCompiler";
import { composeAndSaveRunArtifact } from "../agents/runSummary";

export async function agentRun(job: any) {
  const runId: string = job.data.runId;
  const run = await prisma.agentRun.update({
    where: { id: runId },
    data: { status: "running", startedAt: new Date() },
    include: { agent: true }
  });

  const model = run.agent.defaultModel || "gpt-4o-mini";
  let TOTAL_IN = 0, TOTAL_OUT = 0, TOTAL_CRED = 0;

  const bill = async (inTok: number, outTok: number, label: string, meta: any = {}) => {
    const credits = estimateCredits(model, inTok, outTok);
    await chargeCredits(run.userId, credits, "agent_step", { runId, label, ...meta, model });
    TOTAL_IN += inTok; TOTAL_OUT += outTok; TOTAL_CRED += credits;
    return credits;
  };

  const persistStep = async (index:number, nodeId: string, tool: string, status: string, request?: any, response?: any, error?: string) => {
    const existing = await prisma.agentStep.findFirst({ where: { runId: run.id, index }});
    if (!existing) {
      await prisma.agentStep.create({ data: { runId: run.id, index, tool, status, request, response, error }});
    } else {
      await prisma.agentStep.update({ where: { id: existing.id }, data: { status, request, response, error }});
    }
  };

  try {
    if (run.agent.graph?.nodes?.length) {
      // GRAPH MODE
      const compiled = compileGraphToSteps(run.agent.graph as any);
      await prisma.agentStep.create({
        data: { runId: run.id, index: 0, tool: "plan", status: "done", request: { mode:"graph" }, response: { compiled } }
      });
      const outputs = await executeCompiledSteps({ bill, projectId: run.projectId, userId: run.userId, model, persistStep }, compiled);
      const lastNodeId = compiled[compiled.length - 1]?.nodeId;
      const last = lastNodeId ? outputs[lastNodeId]?.response : null;

      await prisma.agentRun.update({
        where: { id: run.id },
        data: { status: "succeeded", output: last, finishedAt: new Date(), tokensIn: TOTAL_IN, tokensOut: TOTAL_OUT, creditsUsed: TOTAL_CRED }
      });

      // Compose Markdown summary artifact
      await composeAndSaveRunArtifact(run.id);

      return { ok:true };
    }

    // FALLBACK: use LLM planner (previous behavior)
    const planStep = await Tools.plan({ userId: run.userId, projectId: run.projectId, model, bill } as any, run.goal);
    await prisma.agentStep.create({ data: {
      runId: run.id, index: 0, tool: "plan", status: "done", request: { goal: run.goal }, response: { steps: planStep }
    }});

    let idx = 1; let last: any = null;
    for (const st of planStep) {
      await persistStep(idx, `step-${idx}`, st.tool, "running", st.input);
      // @ts-ignore
      const resp = await Tools[st.tool]({ userId: run.userId, projectId: run.projectId, model, bill } as any, st.input || {});
      await persistStep(idx, `step-${idx}`, st.tool, "done", st.input, resp);
      last = resp; idx++;
    }

    await prisma.agentRun.update({
      where: { id: run.id },
      data: { status: "succeeded", output: last, finishedAt: new Date(), tokensIn: TOTAL_IN, tokensOut: TOTAL_OUT, creditsUsed: TOTAL_CRED }
    });

    await composeAndSaveRunArtifact(run.id);
    return { ok:true };

  } catch (e:any) {
    await prisma.agentRun.update({
      where: { id: run.id },
      data: { status: "failed", error: e.message, finishedAt: new Date(), tokensIn: TOTAL_IN, tokensOut: TOTAL_OUT, creditsUsed: TOTAL_CRED }
    });
    // Even on failure, write a summary to help debugging
    await composeAndSaveRunArtifact(run.id).catch(()=>{});
    return { ok:false };
  }
}

3) Result composer → Markdown artifact

Builds a readable report (header, runtime stats, step table, collapsible JSON blocks), and—if a graph was used—adds a Mermaid flowchart derived from agent.graph.edges.

apps/worker/src/agents/runSummary.ts
import { prisma } from "@ai/shared/prisma";

function codeBlock(lang: string, s: string) {
  return "```" + lang + "\n" + s + "\n```";
}

function asTable(rows: Array<{ idx:number; tool:string; status:string; credits:number; inTok:number; outTok:number }>) {
  const header = "| # | tool | status | credits | in | out |\n|---|---|---|---:|---:|---:|";
  const lines = rows.map(r => `| ${r.idx} | ${r.tool} | ${r.status} | ${r.credits} | ${r.inTok} | ${r.outTok} |`);
  return [header, ...lines].join("\n");
}

function mermaidFromGraph(graph: any) {
  if (!graph?.nodes?.length || !graph?.edges?.length) return "";
  const nodeLabel = (n:any) => (n?.data?.label || n?.data?.tool || n.id);
  const lines = ["graph TD"];
  for (const n of graph.nodes) lines.push(`${n.id}[${nodeLabel(n)}]`);
  for (const e of graph.edges) lines.push(`${e.source} --> ${e.target}`);
  return "```mermaid\n" + lines.join("\n") + "\n```";
}

export async function composeAndSaveRunArtifact(runId: string) {
  const run = await prisma.agentRun.findUnique({
    where: { id: runId }, include: { steps: { orderBy: { index: "asc" } }, agent: true }
  });
  if (!run) return;

  // Roll up per-step credits/tokens from step.response meta if present (optional)
  const rows = run.steps.map(s => ({
    idx: s.index,
    tool: s.tool,
    status: s.status,
    credits: s.credits ?? 0,
    inTok: s.tokensIn ?? 0,
    outTok: s.tokensOut ?? 0
  }));

  const header = `# Agent Run Summary

**Agent:** ${run.agent?.name ?? run.agentId}  
**Run ID:** ${run.id}  
**Status:** ${run.status}  
**Goal:** ${run.goal || "(graph-run)"}  

**Credits:** ${run.creditsUsed}  
**Tokens:** in ${run.tokensIn} • out ${run.tokensOut}  

**Started:** ${run.startedAt?.toISOString() ?? ""}  
**Finished:** ${run.finishedAt?.toISOString() ?? ""}`;

  const table = asTable(rows);

  const details = run.steps.map(s => {
    const req = codeBlock("json", JSON.stringify(s.request ?? {}, null, 2));
    const res = s.response ? codeBlock("json", JSON.stringify(s.response ?? {}, null, 2)) : "";
    const err = s.error ? ("\n**Error:** " + codeBlock("text", s.error)) : "";
    return `### Step ${s.index}: ${s.tool} — ${s.status}\n**Request**\n${req}\n\n**Response**\n${res}${err}`;
  }).join("\n\n");

  const mermaid = run.agent?.graph ? mermaidFromGraph(run.agent.graph) : "";

  const tail = `## Output
${codeBlock("json", JSON.stringify(run.output ?? {}, null, 2))}`;

  const md = [header, "", mermaid, "", "## Steps", table, "", details, "", tail].join("\n");

  // Save as markdown artifact for the project (or user if no project)
  await prisma.artifact.create({
    data: {
      name: `Agent Run Summary — ${run.agent?.name ?? run.agentId}`,
      kind: "markdown",
      data: { md } as any,
      userId: run.userId,
      projectId: run.projectId || undefined
    }
  });
}

4) How to use (quick)

Draw your DAG in the Agent DAG Editor (node data.tool and data.input optional; label can be the tool name).

Save → graph JSON persists to Agent.graph.

Run the agent (from Builder or API).

Worker compiles the DAG → executes steps → logs → composes a Markdown summary artifact you’ll see in ArtifactList.

Templating examples (on a node’s input):

{
  "prompt": "Using the first result: {{step:search.response.results[0].snippet}}"
}